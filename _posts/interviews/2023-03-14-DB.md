---
title: 数据库
author: Yu Mengchi
categories:
  - Interview 
  - 面试知识点
  - 数据库
tags:
  - Interview
  - DataBase
---
  
# 数据库系统面试题

---

- DBA：数据库管理员
- ER图：实体关系图
- 数据库范式：
1. 第一范式：属性（对应表中的字段）不能在被分割，所有关系型数据库中创建的表一定要满足第一范式；
2. 第二范式：<商品名称，供应商名称，商品价格> 分解成 <商品id，商品名称，商品价格> <供应商id，供应商名称> <商品id， 供应商id>；
3. 第三范式：符合第三范式要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。

---

### drop、truncate、delete区别？

- drop：会同时删除表结构；
- truncate：清空所有数据，但不会删除表结构；
- delete：可以删除某一行，如果不指定where条件，则和truncate一样不会删除表结构；

同时drop和truncate是DDL语句，操作立即生效，原数据不放到rollback segment中，不能回滚，操作不触发trigger。而delete语句是DML语句，操作会放到rollback segment中，事务提交之后才生效。

---

### NoSQL有几种类型？

- 键值：Redis
- 文档：MongoDB
- 图形：Neo4j
- 宽列：HBase

---

### 常见的字符集

不同的字符集通常表示这种字符集可以表示的字符范围和编码方式的不同。
- ASCII：表示128个字符，不能表示中文。ASCII扩展字符集可以表示256个字符
- UTF-8：使用最广的编码，包含世界上所有字符。
- GBK：可以看作GB2312的扩展，收录2万多个汉字
- GB2312：收录6700个汉字，生僻字和繁体字没法表示。对于英文字符，GB2312和ASCII码相同，对于非英字符，需要2字节编码

---

### MySQL基础架构

MySQL主要由连接器、分析器、优化器、执行器、存储引擎组成。

- 连接器：主要进行身份认证和检查权限；
- 分析器：分析器会对SQL语句进行检查，查看是否正确；
- 优化器：优化器会选择最优的方案执行SQL语句；
- 执行器：负责执行语句，从存储引擎返回数据；
- 存储引擎：主要负责数据的存储和读取，支持InnoDB、MyISAM、Memory等多种存储引擎。

---

### InnoDB和MyISAM区别？

MyISAM不支持行级锁和事务，而且崩溃后无法安全恢复。

- InnoDB支持表的行级锁，MyISAM只支持表级锁，所以并发能力上InnoDB比MyISAM更优秀；
- InnoDB支持事务，定义了四种隔离级别，MyISAM不支持事务。
- MyISAM不支持外键，InnoDB支持
- MyISAM不支持MVCC，InnoDB支持
- MyISAM不支持数据库异常崩溃后的安全恢复，InnoDB支持
- InnoDB的性能比MyISAM更强大

---

### MySQL日志有哪些？如何工作的？redo日志和undo日志区别？实现什么效果，为什么要加日志？

- binlog：实现主从复制、数据备份
- redo log：保证事务的一致性
- undo log：保证事务的原子性

---

### MySQL如何支持事务的？一个事务的执行流程是什么样的？如何把一组操作作为事务提交执行？事务回滚是如何回滚的？事务的ACID特性是什么？

事务的ACID特性：
- 原子性：原子性表示事务是最小的执行单元，不允许分割，事务的原子性确保事务内的动作要么全部完成，要么全部不起作用。
- 一致性：
- 隔离性：多个用户的事务并发访问数据时，并发事务之间应该是独立的，不能被其他事务干扰；
- 持久性：一个事务被提交之后，对数据库内的数据的改变应该是持久的，即使数据库发生故障也不应该影响执行结果。

---

### 并发事务会带来哪些影响，如何解决？

- 脏读：一个事务对数据修改，但是还没有提交，这时另一个事务读到了未提交的数据，之后第一个事务又回滚了，导致第二个事务读到的数据是错误的。
- 不可重复读（Un repeatable read）：一个事务修改数据，另一个事务同时读取两次数据，前后两次读取可能会因为第一个事务的修改导致读取结果不一致。
- 幻读（Phantom read）：一个事务多次读取同一个数据时，由于另一个事务同步修改，导致多次读取的记录条数不一致，重点是读取的记录条数不一致，和不可重复读类似，不可重复读的重点是多次读取的记录的值不一致。
想要解决幻读，重点是要防止一个事务在读取数据的时候另一个事务删除或新增数据，可以添加表锁+Next key lock

InnoDB在默认的RR（可重复读）隔离级别下使用MVCC+Next Key Lock防止幻读。

---

### 事务的四种隔离级别

- 读未提交（read uncommitted）：最低的隔离级别，允许读取未提交事务的数据变更，会导致脏读、幻读、不可重复读；
- 读已提交(read committed)：其他并发事务只能读取其他事务已经提交的修改，可以防止脏读，幻读和不可重复读仍然有可能；
- 可重复读(repeatable-read)：保证同一个事务里面可以多次读取数据，保证多次读取数据是一致的，除非是自己修改的。可以防止脏读和不可重复读问题，但是幻读还是有可能；
- 串行化(serializable)：所有事务串行执行。最高的隔离级别，可以防止脏读、不可重复读和幻读。

---

### 并发事务控制方式有哪些？

- 锁： 写锁和读锁
- MVCC：多版本并发控制，对一份数据存储多个版本，通过事务的可见性保证事务能看到自己应该看到的版本，
通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。

---

### MVCC在InnoDB中是如何实现的？

---

### MySQL使用哪些锁？
- 行锁
- 表锁

### InnoDB有几种行锁？
- record lock（记录锁）：会锁定单个行
- gap lock（间隙锁）：会锁定一个范围，不会锁定行记录本身
- next-key lock（临键锁）：会锁定一个范围，也会锁定这个范围内的记录本身。主要是为了解决幻读问题，避免其他并发事务插入新记录。


---

### InnoDB存储引擎底层使用的数据结构是什么？B+树有什么特点？为什么使用B+树？

---

### 什么是聚簇索引？

---

### MySQL有哪些索引？

---

### 使用索引应该注意什么？

哪些字段适合做索引？
- 经常查询的字段
- 不为null的字段
- 被作为where条件查询的字段
- 被频繁用来连接的字段

使用索引应该注意什么？
- 经常更新的字段不应该作为索引
- 每张表最好不超过5个索引，因为mysql优化器会选择最佳的执行计划，会耗时
- 尽可能建联合索引
- 避免索引失效

---

### 什么情况下索引会失效？

- 使用select * 
- 创建了组合索引但是查询条件未遵循最左匹配原则
- 在索引列上进行计算，使用函数、类型转换等操作
- 以%开头的like查询
- 使用or的时候，如果有一个字段没有索引，会导致其他字段的索引失效
- 发生隐式转换（操作符两边类型不一样，比如一定要用双引号表明是字符串：where name="lijia"）

---

### 查看索引使用情况？


---

### sql执行缓慢应该如何解决？如何调优？导致慢查询的原因？

- 索引失效


---


### sql使用应该注意哪些事项？


---

### 如何使用读写分离(解决读高并发)和分库分表(解决存储压力)提高查询性能

首先使用主从架构部署多台MySQL服务器，第二步实现主从复制，第三步把写请求发到主服务器，读请求分发到从服务器。
主写从读，会带来主从不一致问题，

---

### 主从复制过程

1. 主库写数据到binlog
2. 主库创建binlog dump线程，把binlog发送到从库，从库创建IO线程，接收binlog
3. 从库IO线程接收binlog后写入到relay log中
4. 从库创建SQL线程读取relay log同步数据


---

### 分库分表如何实现

- 垂直分表：把一个列数比较多的表拆分为多个表；
- 水平分表：把一个行比较多的表拆分成多个表；

数据水平分片之后，通过分片算法决定存放在那个表中。可以
- 哈希分片
- 范围分片
- 地理位置分片
- 融合分片

分表后带来的问题是join连接比较麻烦，事务操作无法保证，如何生成全局唯一的主键id

---
