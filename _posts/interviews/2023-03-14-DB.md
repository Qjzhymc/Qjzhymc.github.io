---
title: 数据库
author: Yu Mengchi
categories:
  - Interview 
  - 面试知识点
  - 数据库
tags:
  - Interview
  - DataBase
---

### drop、truncate、delete区别？
- drop：会同时删除表结构；
- truncate：清空所有数据，但不会删除表结构；
- delete：可以删除某一行，如果不指定where条件，就和truncate一样不会删除表结构；

> 而且drop和truncate是DDL语句，操作立即生效，原数据不放到undo log中，不能回滚，操作不触发trigger。
> 而delete语句是DML语句，操作会放到rollback segment中，事务提交之后才生效。

---
### truncate和drop有什么区别？truncate有什么隐患
1. truncate会删除表的数据，但是保留表的结构，drop会把表数据和表结构、表索引都删掉。
2. truncate不会对表占用的空间进行回收，drop会释放表占用的空间。
3. 而且truncate不会记录执行日志，所以没法回滚。

---
### NoSQL有几种类型？
- 键值：Redis，适合快速查找的场景，比如缓存系统
- 文档型：MongoDB，扩展了键值存储的概念，允许迁入更复杂的数据结构，比如JSON、XML
- 图数据库：Neo4j，适合社交网络分析、推荐引擎，存储具有高度互联关系的数据
- 宽列：HBase，以列为单位存储数据。

---
### 常见的字符集
不同的字符集通常表示这种字符集可以表示的**字符范围**和**编码方式**的不同。
- ASCII：使用7位二进制表示一个字符。表示128个字符，不能表示中文。ASCII扩展字符集可以表示256个字符
- UTF-8：使用1~4个字节表示一个字符。使用最广的编码，包含世界上所有字符。
- GB2312：收录6700个汉字，生僻字和繁体字没法表示。对于英文字符，GB2312和ASCII码相同，对于非英字符，需要2字节编码
- GBK：可以看作GB2312的扩展，收录2万多个汉字

---
### 数据库里int，char，vchar区别？

1. TINYINT
 - 1字节，性别
2. SMALLINT
 - 2字节，年龄
3. MEDIUMINT
 - 3字节
4. INT
 - 4字节，ID
5. BIGINT
 - 8字节，时间戳

6. FLOAT 4字节
7. DOUBLE 8字节 财务计算，精度高
8. DECIMAL(M,D) 自定义精度，最大M位，保留D位小数


9. CHAR(N) 固定长度
10. BINARY(N) 二进制形式的CHAR  存储二进制数据，如加密密钥

11. VARCHAR(N) 动态长度
12. TEXT 大文本，不支持全文索引前缀 最大65535字节
13. MEDIUMTEXT 超长文本 博客文章 最大16777615字节
14. LONGTEXT 超大型文本 小说

二进制字符串
15. VARBINARY(N)  可变长度二进制数据
16. BLOB 最长65535字节 二进制大对象，比如图片
17. MEDIUMBLOB 更大的二进制数据
18. LONGBLOB 极大二进制数据，如视频

日期时间
19. DATE '1000-01-01' 到 '9999-12-31'  3字节 年月日，出生日期
20. TIME '-838:59:59' 到 '838:59:59'  3字节 时分秒
21. DATETIME  8字节 年月日时分秒 精确记录时间，如订单时间
22. TIMESTAMP 4字节，年月日时分秒  自动更新时间戳
23. YEAR 1字节 年份

特殊类型
24. ENUM 
25. SET
26. JSON
27. 空间数据类型  POINT，LINESTRING，POLYGON

---
### 时间戳前三种方式及其运用场景

1. DATETIME可以存储更大范围的时间，1000-01-01 00:00:00 到 9999-12-31 23:59:59
TIMESTAMP只能存储1970-01-01 00:00:01 UTC 到 2038-01-19 03:14:07 UTC

2. 不依赖时区的用DATETIME
3. 如果为空， DATETIME可以存NULL， TIMESTAMP如果没有设置默认值，会存当前时间
4. 如果记录的是事件发生的时间，应该用TIMESTAMP；需要自动更新时间；节省存储空间；跨时区需求

- 优先选 TIMESTAMP：用于新增 / 更新时间戳、需要自动更新、跨时区场景，且时间范围在 1970-2038 年之间。
- 优先选 DATETIME：用于历史时间、未来时间、固定时区时间、需存储 NULL 的场景。

---
### MySQL基础架构
MySQL服务端主要由连接器、解析器、优化器、存储引擎组成。

- 连接器：主要进行连接管理、身份认证和检查权限；
- 解析器：负责解析SQL语句，验证语法和语义的正确性
- 优化器：优化器会选择最优的执行计划执行SQL语句；决定表的访问顺序、选择索引；
- 存储引擎：主要负责数据的存储和读取，支持InnoDB、MyISAM、Memory等多种存储引擎。
- 物理文件：有redolog、undolog、binlog、errorlog、querylog、slowlog、data、index

---
### InnoDB和MyISAM区别？

- InnoDB支持表的行级锁，MyISAM只支持表级锁，所以并发能力上InnoDB比MyISAM更优秀；
- InnoDB支持事务，定义了四种隔离级别，MyISAM不支持事务。
- MyISAM不支持外键，InnoDB支持
- MyISAM不支持MVCC(多版本并发控制)，InnoDB支持
- 数据库发生异常崩溃后，如果是MyISAM不支持安全恢复的，InnoDB可以通过日志恢复

---
### innodb和Myisam区别？
1. innodb提供事务支持，myisam不支持事务。
2. innodb支持行级锁和表级锁，而myisam只支持表级锁。
3. InnoDB 支持 ACID（原子性、一致性、隔离性、持久性）事务特性，MyISAM 不支持。
4. 并发性能：InnoDB 的并发性能相对 MyISAM 更好，读写并发能力更强。
5. 关注点：InnoDB 关注于提高事务处理能力和并发性能，MyISAM 关注于查询处理能力。
6. innodb需要更多存储空间，存储索引，而myisam的索引在表数据文件之外，不会占用太多存储空间。
7. 数据完整性：InnoDB 对数据完整性采用了严格的约束检查，可以防止损坏和丢失数据，而 MyISAM 没有这种保护机制。

---
### MySQL日志有哪些？如何工作的？redo日志和undo日志区别？实现什么效果，为什么要加日志？
- binlog：记录数据变更的所有操作，实现主从复制、数据备份
- redo log重做日志：主要作用是确保在发生崩溃的时候能够恢复未完成的事务。确保事务的持久性
- undo log撤销日志：记录的是数据修改前的原始数据。主要用于支持**事务回滚**以及**实现MVCC**。保证事务的原子性和隔离性

---
### binlog有几种格式？
- statement（SBR）:记录的是修改数据的sql，每一条会修改数据的sql都会记录在binlog里；
- row（RBR）:记录的是每条记录被修改的结果，不记录sql语句上下文信息，只保存哪条记录被修改；
- mixed（MBR）:statement和row的混合体。

---
### MySQL如何支持事务的？一个事务的执行流程是什么样的？如何把一组操作作为事务提交执行？事务回滚是如何回滚的？事务的ACID特性是什么？一致性具体含义是什么？

如何支持事务：
- MySQL通过InnoDB存储引擎支持事务。

事务执行流程：
1. 开始事务：通过START TRANSACTION或BEGIN语句开启一个新的事务；
2. 执行sql操作：在事务中执行一系列的SQL语句，比如INSERT、UPDATE、DELETE，这些操作不会立即执行，而是暂时保存在事务日志中；
3. 提交事务：如果所有操作都成功完成，则使用COMMIT命令将事务所做的更改永久同步到数据库中；
4. 回滚事务：如果有任何错误，可以使用ROLLBACK命令撤销事务中的所有操作。

事务如何回滚：
1. 事务执行的时候会把修改的数据、修改前后的值、操作的时间戳信息存放在事务日志里；
2. 所以回滚的时候，会从事务日志里找到所有记录，包含事务对数据库做的所有操作；
3. 然后，数据库系统按照事务日志记录的逆序进行反向操作。

事务的ACID特性：
- 原子性：原子性表示事务是最小的执行单元，确保事务内的动作要么全部完成，要么全部不起作用。
- 一致性：事务必须使数据库从一种一致状态转换为另一种一致状态。不会破坏数据库的完整性约束；主键约束、外键约束、唯一约束；
- 隔离性：多个用户的事务并发访问数据时，并发事务之间应该是独立的，不能被其他事务干扰；
- 持久性：一个事务被提交之后，对数据库内的数据的改变应该是持久的，即使数据库发生故障也不应该影响执行结果。

---
### acid怎么实现
事务、锁机制、日志

---
### 事务特性？i是啥？
1. A原子性：一个事务中的所有操作要么全部成功执行，要么全部不执行。中途发生错误需要回滚到初始状态。
- 实现方式：日志
2. C一致性：事务必须从一个一致的状态转移到另一个一致的状态。事务开始前和结束和，数据库都应该处于一个合法的状态。
- 满足所有的约束条件、触发器以及存储过程等逻辑规则；
- 什么叫一致的状态：
3. I隔离性：多个并发事务之间相互独立、互不影响。不同的隔离级别提供了不同程度的保护，防止脏读、不可重复读、幻读等问题。
- 四种隔离级别：
4. D持久性：一旦事务被提交，对数据库所做的所有更改都应该是永久性的。
- 实现方式：持久化写入确认机制

---
### MySQL事务原理
- 通过undo log保证回滚，实现事务的原子性
- 通过redo log实现故障后恢复，实现事务的持久性
- 通过锁机制和MVCC实现隔离性，共享锁(读锁)，排他锁(写锁)
- 最终保证一致性

---
### 并发事务会带来哪些影响，如何解决？
- 脏读：一个事务对数据修改，但是还没有提交，这时另一个事务读到了未提交的数据，之后第一个事务又回滚了，导致第二个事务读到的数据是错误的。
- 不可重复读：一个事务修改数据，另一个事务同时读取两次数据，前后两次读取可能会因为第一个事务的修改导致读取结果不一致。
- 幻读（Phantom read）：一个事务多次读取同一个数据时，由于另一个事务同步修改，导致多次读取的记录条数不一致，重点是读取的记录条数不一致，和不可重复读类似，不可重复读的重点是多次读取的记录的值不一致。
想要解决幻读，重点是要防止一个事务在读取数据的时候另一个事务删除或新增数据，可以添加表锁+Next key lock

InnoDB在默认的RR（可重复读）隔离级别下使用MVCC+Next Key Lock防止幻读。

---
### 事务的四种隔离级别
- 读未提交（read uncommitted）：最低的隔离级别，允许读取未提交事务的数据变更，会导致脏读、幻读、不可重复读；
- 读已提交(read committed)：并发事务只能读取其他事务已经提交的修改，只可以防止脏读，幻读和不可重复读仍然有可能发生；
- 可重复读(repeatable-read)：InnoDb的默认隔离级别。保证同一个事务里面可以多次读取的数据是一致的，除非是自己修改的。可以防止脏读和不可重复读问题，但是幻读还是有可能；所以InnoDB在这个隔离级别下使用MVCC+Next Key Lock防止幻读
- 串行化(serializable)：所有事务串行执行。最高的隔离级别，可以防止脏读、不可重复读和幻读。

MVCC：为每个事务提供一个一致性视图。每个事务在开始时都会生成一个快照，所有查询都基于这个快照执行，其他事务在此之后提交的修改不会影响当前事务的查询结果。
所以在同一个事务中，多次执行相同的查询时，结果是一致的，不会出现"不可重复读"或"幻读"，但是不能完全避免幻读。

Next-Key Locking：这是InnoDB默认的锁定策略，结合了**行锁+间隙锁**。
- 行锁：锁定具体的行数据
- 间隙锁：锁定索引之间的间隙，防止其他事务在这些间隙中插入新数据

通过Next-Key Locking，InnoDB能够锁定查询范围内的所有现有数据行以及潜在的插入位置，从而防止其他事务在这些范围内插入新数据。可以避免幻读。

---
### 不同事务隔离级别
1. 读未提交：允许一个事务看到其他事务未提交的更改；
- 会产生的问题：脏读、不可重复读、幻读；
- 没有限制对数据的访问，很少使用
2. 读已提交：不允许读取未提交的数据，避免脏读；
- 会产生的问题：不可重复读(多次读取数据不一致)、幻读(多次查询结果集不同)
- 实现方式：行级锁(共享锁)
3. 可重复读：在一个事务内多次读取返回相同的结果，解决不可重复读的问题；
- 会产生的问题：幻读(没法阻止其他事务插入新记录)(InnoDB通过间隙锁解决幻读)
- 实现方式：间隙锁+MVCC
4. 序列化：事务必须串行化执行

> InnoDB默认的隔离级别是可重复读

---
### 并发事务控制方式有哪些？
- 锁： 写锁和读锁
- MVCC：多版本并发控制，对一份数据存储多个版本，通过事务的可见性保证事务能看到自己应该看到的版本，
通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。

---
### MVCC在InnoDB中是如何实现的？MVCC的原理
在MVCC中，每个事务在读取数据时会看到一个独立的快照版本，而不是看到其他并发事务正在修改的版本。这个快照版本是通过在每个数据行上添加隐藏的事务版本号来实现的。

**底层实现：**通过undo log版本链和ReadView机制来实现。**undo log保存历史快照，readView可见性规则帮助判断读取哪个版本的数据。**
1. Undo log版本链：每行数据保存多个历史版本，通过事务ID和回滚指针连接
 - 每次更新数据，会生成一个新数据版本，让其指向上一个版本，老版本数据不会丢，可以通过Undo Log版本链找到；
2. readView：事务开始时生成的快照，决定当前事务能看到哪些版本的快照。
 - 每次读取数据，会生成一个ReadView，根据readView的可见性规则判断哪个版本的数据对当前事务可见。

---
### MVCC如何保证事务可见
1. MVCC为每个事务创建一个快照来解决多个事务同时访问数据库带来的数据不一致性和读写冲突。
2. 事务开始时，会获得一个当前快照的视图，该视图显示了在该事务开始之前对数据库进行的所有更改。
3. 然后，当该事务对数据库进行更改时，这些更改将在快照中创建一个新版本的数据。其他事务将继续使用它们开始时获得的视图，
4. 即使在更改进行时，它们也不会看到新版本的数据，这样，每个事务都可以在自己的版本中查看数据，并且不会相互干扰，从而确保事务的可见性。

---
### 快照读和当前读
是两种不同的读取机制
1. 快照读：读取事务开始时的数据快照，不是最新数据，通过MVCC实现，每个事务读取自己可见的版本，不会锁定数据，可能读到旧数据。在RR隔离级别下，select默认是快照读
2. 当前读：读取最新提交的数据，对读取的数据加锁，
 - 排他锁 SELECT ... FOR UPDATE、UPDATE、DELETE都是排他锁
 - 共享锁 SELECT ... LOCK IN SHARE MODE 

---
### 可重复读事务隔离级别的实现原理？
- 读取数据的时候，事务对当前被读取的数据不加锁，并且是快照读，读取事务开始时的数据快照，不是最新数据，通过MVCC实现；
- 更新数据的时候，事务在更新数据的瞬间，必须对数据加行级排它锁（record lock,gap lock,next-key lock）,直到事务结束才释放。

---
### MySQL使用哪些锁？
1. 行级锁
- 记录锁:锁定索引记录，防止其他事务对同一记录进行修改或删除；
- 间隙锁:锁定索引记录之间的间隙，防止其他事务在这个间隙中插入新的记录，从而避免幻读问题；
- Next-Key Locks:是记录锁+间隙锁的组合，即锁定记录也锁定记录之间的间隙，是InnoDB默认的锁定方式，在可重复读隔离级别下用于防止幻读。
2. 表级锁
3. 全局锁：对整个数据库实例加锁，通常用于备份操作

---
### mysql有哪些锁，间隙锁是什么？
1. 行级锁有：
- 记录锁(record locks): 锁定查找到的记录行
- 间隙锁(gap locks): 锁定一个范围，但是不包括行本身，防止其他事务在这个范围内插入新记录，所以其他事务还是可以更新已有的记录、查询已有的记录的。用于可重复读隔离级别下，避免幻读问题；
- next-key locks: 是记录锁和间隙锁的结合，用于防止其他事务在这个范围内插入、更新、删除操作。

2. 表级锁有：
- 意向共享锁(Intention Shared Lock,IS):表示事务打算对表中的某些行设置共享锁；
- 意向排他锁(Intention Exclusive Lock, IX):表示事务打算对表中的某些行设置排他锁；
- 共享锁(Shared Lock,S):允许事务读取一行，多个事务可以同时持有同一行的共享锁；
- 排他锁(Exclusive Lock, X): 允许事务删除或更新一行，只有一个事务可以获取某一行的排他锁。

3. 间隙锁是什么？
   间隙锁是InnoDB存储引擎在可重复读隔离级别下使用的一种锁机制。主要用来解决幻读问题，幻读就是指在一个范围内执行相同的两次查询时，可能会发现由于有新插入的行导致两次查询结果集不同。
- 间隙锁的作用就是它不会锁定特定的记录，而是锁定两个记录之间的间隙，防止其他事务在这个间隙内插入新记录；
- 可以防止幻读，保证了事务的隔离性。

---
### InnoDB有几种行锁？
- 记录锁record lock：会锁定单个行
- 间隙锁gap lock：会锁定一个范围，不会锁定行记录本身
- 临键锁next-key lock：会锁定一个范围，也会锁定这个范围内的记录本身。主要是为了解决幻读问题，避免其他并发事务插入新记录。

---
### InnoDB存储引擎底层使用的数据结构是什么？B+树有什么特点？为什么使用B+树？
B+树

B+树特点：
1. 所有数据都在叶子节点上：非叶子节点只存储键值和指向下一个节点的指针；
2. 叶子节点之间有链接：B+树的叶子节点是顺序连接的，通常是双向链表，可以方便地实现范围查询；
3. B+树每个节点有很多子节点，减少了树的高度。减少了磁盘IO次数；
4. 平衡树结构：从根节点到任何一个叶子节点的距离都是相同的，确保每次查找、插入或删除的时间复杂度都是O(logn).

为什么使用B+树：
1. 优化磁盘IO性能：减少了磁盘IO操作的次数；
2. 支持高效的范围查询：叶子节点顺序相连；

为什么使用B+树不适用跳表？(从空间效率和磁盘IO性能，并发控制来讲)

---
### 索引结构B+树结构？
1. 所有数据指针存放在叶子节点上；非叶子节点存放关键字和子节点指针，叶子节点存放关键字还有指向实际数据记录的指针。
2. 叶子节点之间通过链表形式相互连接，所以方便进行范围查询；
3. B+树是平衡树，所有叶子节点在同一层；
4. 树的高度较低，每个节点都有多个子节点；

---
### 乐观锁
乐观锁是一种并发控制技术，在乐观锁情况下，每个事务在读取共享资源之前，不会对资源进行上锁，而是检查资源的当前状态，
比如使用版本号或时间戳机制来跟踪资源的状态，以确保它没有被其他事务更改。如果检查发现资源已经被更新，则事务会回滚并
重试操作。

> 乐观锁可以提高系统的并发性和吞吐量。

---
### 表更新时，乐观锁怎么实现
1. 使用版本号
2. 使用时间戳

> 实现乐观锁时，在数据表中添加一个版本号字段或时间戳字段，每次更新数据时都会将版本号或时间戳加1，当
提交数据时，检查当前版本号或时间戳是否和提交前一致，如果一致则提交成功，否则回滚。

---
### 乐观锁和悲观锁
悲观锁实现：表锁、行锁
1. SELECT ... FOR UPDATE:排他锁
   用上面语句执行查询时，会对查询结果的每一行加上排他锁，直到当前事务结束
```roomsql

START TRANSACTION;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;

COMMIT;

```

2. SELECT ... LOCK IN SHARE MODE:共享锁
   会给查询到的行加共享锁，其他事务也可以加共享锁但是不能加排他锁，适用于只读场景。

3. LOCK TABLES accounts WRITE;表级锁

> 还可以不用sql语句加锁，可以在应用层加锁，在redis上设置一个锁，可以使用redis的分布式锁。

---
### 悲观锁和乐观锁区别？
1. 悲观锁假设并发访问概率很高，会对资源进行锁定防止其他线程对它修改。
2. 乐观锁假设并发访问概率较低，采用版本号或时间戳的方式来控制并发修改，当一个事务需要更新某个记录的时候，会先记录该记录的版本号或时间戳，
   在提交的时候该记录的版本号或时间戳与最开始是不是一样，如果不一样，说明有其他事务修改了记录，事务操作失败，需要重试。

悲观锁适用在改动频繁的情况，乐观锁适用于读多写少的场景。

---
### 索引查询过程的磁盘IO读取策略


---
### 索引下推
索引下推是一种查询优化技术。把过滤和排序操作放在数据库引擎中的存储引擎层级来执行，而不是在查询过程中将整个数据集传输到查询引擎层级来处理。
可以减少数据传输和处理的时间，提高查询性能。

当查询条件里有某个索引的条件时候，会先在索引的遍历过程中提前过滤

---
### 什么是聚簇索引？
聚簇索引将数据存储在索引中，而不是独立的数据页中。可以提高查询效率
- 聚簇索引通常基于主键；
- 如果表没有主键，InnoDB会选择一个唯一的非空列作为聚簇索引；如果连这样的列都没有，InnoDB会隐式创建一个6字节的ROWID作为主键；

InnoDB中的聚簇索引：
- 非叶子节点：存储索引键值以及指向叶子节点的指针。这些节点不存储实际的数据行，只用于定位数据；
- 叶子节点：存储索引键值以及对应的实际数据行(完整数据记录)。每个叶子节点还包含指向相邻叶子节点的指针，用于支持范围查询；

聚簇索引特点：
- 数据按主键排序：表中的数据行按照主键的顺序存储，因此通过主键访问数据时非常高效；
- 快速范围查询：
- 主键唯一性：主键必须唯一，因为它是聚簇索引的键值。

聚簇索引的优势：
- 数据访问高效:数据行直接存储在B+树的叶子节点上，通过主键访问数据只需一次B+树查找
- 范围查询快速:
- B+树高度较低，减少了磁盘IO次数

聚簇索引的缺点：
- 如果主键频繁更新，会导致重新组织聚簇索引，增加维护成本；主键应尽量选择单调递增的值(比如自增ID);
- 通过辅助索引查询数据时，需要先找到主键值，再通过聚簇索引查找实际数据。

---
### MySQL有哪些索引？

1. **主键索引**:每张表只能有一个主键；一种特殊的唯一索引，要求索引列的值唯一且非空；InnoDB使用主键作为聚簇索引的基础；
2. **唯一索引**:索引列的值唯一，但允许有空值；一个表可以有多个唯一索引；
3. **普通索引**:最基本的索引类型，没有任何限制条件；适用于加速查询操作；
4. 全文索引:专门用于全文索引，支持复杂的文本匹配查询；适用于大文本字段，比如varchar、text
5. 联合索引:组合索引或复合索引，在多个列上创建的一个索引；创建时需要注意索引列的顺序；通过对多个列创建索引优化查询性能，查询条件涉及多个列的时候；
6. 空间索引:用于地理空间数据类型Geometry类型的索引
7. 覆盖索引:不是一个独立的索引类型，指的是一个索引如果包含了查询所需的所有列，则可以直接从索引中获取数据而无需访问表的数据行。通过索引直接提供查询所需的所有数据

```roomsql

CREATE UNIQUE INDEX ON TABLE_NAME (COL1,COL2...);

CREATE INDEX ON TABLE_NAME (COL1,COL2...);

```

> 一个组合索引也可以同时是一个覆盖索引，两者并不互斥；

---
### 覆盖索引有什么优点
覆盖索引就是指查找的时候，需要查找的字段可以在索引中直接返回，不用从磁盘中读取。这样mysql可以只通过索引就能返回需要的数据，性能比较快。


---
### MySQL主键为什么一般用自增
保证唯一性

---
### B+树索引结构的工作原理
1. B+树的每个节点都有关键字列表，关键字列表按顺序排列，每个节点都有2个以上的子树，关键字左子树中的关键字都小于该关键字，右子树中的关键字都大于等于该关键字；
2. 非叶子节点只存放关键字，叶子节点存放关键字和data记录
3. 叶子节点之间用指针连接，所有叶子节点的关键字按关键字大小顺序排序。

查找的时候：可以从最左边的叶子节点开始顺序查找，也可以从根节点开始自上而下查找；

插入操作时，从叶子节点开始查找插入位置，并且判断所插入节点的关键字数量是不是超过了规定的数量，如果超过了，需要分裂成两个节点。

---
### B+树定义？结构？特点？

B+树是一种平衡的多路搜索树，主要用在数据库和文件系统中作为索引结构，可以减少磁盘IO操作次数，提高查询效率。

特点：
1. 所有叶子节点在同一层：所有数据访问都需要相同数量的磁盘读取。
2. 每个节点可以有多个子节点：树的高度较低。
3. 所有叶子节点通过链表链接在一起：所以范围查询很高效，找到起始点后沿着链表遍历找到结束点。

---
### 主键索引和其他辅助索引在B+树上有什么不同？
1. 主键索引：不重复(唯一)、不为空的列；如果没有指定，InnoDB会自动生成一个隐藏列作为主键索引
- 叶子节点存放的是索引键值和数据行的所有列数据
2. 辅助索引：可以重复(除非是唯一索引)；
- 叶子节点是索引键值和对应的主键值，不是整行数据，根据这个主键值去主键索引查找完整数据行，这种两次查找的过程称为"回表".

---
### 联合索引是怎么查找的？
查找元素时，会先比较第一个列的值，如果相同则再比较第二个列的值。

---
### 构建联合索引要注意什么？
1. 分析查询频率较高的字段
2. 区分度高的字段排前面
3. 把查询的字段加入索引，避免回表查询

> 也可以基于多个查询列，创建一个哈希列，把这个哈系列创建索引，也可以加速多列查找：hash_col=MD5(CONCAT(val1, val2))

---
### 数据库B+树高度和入度计算
树的高度h与**总节点数N**和**阶数n**有关。

阶数为n(即每个节点最多有n个子节点)，总节点为N，则高度h=以n为底，N的对数；

---
### B+树的层高由什么决定？
总节点数 节点的阶数(每个节点的子节点数量)

---
### 使用索引应该注意什么？
哪些字段适合做索引？
- 经常查询的字段
- 不为null的字段
- 被作为where条件查询的字段
- 被频繁用来连接的字段

使用索引应该注意什么？
- 经常更新的字段不应该作为索引
- 每张表最好不超过5个索引，因为mysql优化器会选择最佳的执行计划，会耗时
- 尽可能建组合索引(联合索引)，组合索引要特别注意列的顺序，最常用于查询条件的列应该放在前面；**最左匹配原则**
- 避免**索引失效**

---
### 什么情况下索引会失效？
- 使用select * ,如果一个查询返回表中大部分的数据行，MySQL优化器会认为**全表扫描比使用索引更高效**
- 创建了联合索引但是查询条件未遵循**最左匹配原则** (联合索引使用or连接也不行)
- 在索引列上进行计算，**使用函数、类型转换、数学运算**等操作
- **以通配符开头的like查询**，比如以%或_开头；
- 使用or的时候，如果有一个字段没有索引，会导致其他字段的索引失效
- 发生**隐式类型转换**（操作符两边数据类型不一样，或字符集不一样，比如一定要用双引号表明是字符串：where name="lijia"）

---
### 什么时候索引失效
1. select *
2. 索引列使用了函数计算或表达式计算
3. 组合索引没有遵守最左匹配原则
4. 条件查询中使用了以%开头的like查询
5. 表数据比较少的时候，不会使用索引
6. 使用or连接查询条件的时候，如果存在字段没有索引，就不会使用到索引

---
### 什么是最左匹配规则？
是指在使用联合索引时，查询条件中的列必须按照索引中定义的顺序从左到右匹配，至少要包含联合索引的第一个列。

---
### 联合索引为什么有最左匹配规则？
- 主要是由B+树工作的原理决定的，建一个联合索引实际上是创建了一个基于多个字段组合的B+树。这个树首先根据第一个字段排序，第一个字段值相同再根据第二个字段排序，所以在查找的时候，如果缺少了前面的字段，就无法确定后续字段的具体位置，所以就不能利用到联合索引定位了。

**设计联合索引的原则：**
1. 最左边的列通常是选择性更高的列，这个列的不同值的数量更多，这样可以在早期阶段过滤掉大量不符合条件的记录，提高查询效率。
2. 尽量使用索引覆盖，就是查询的所有字段都可以通过索引获得，数据库可以直接从索引中获取所需的信息，不需要访问表数据本身，查询速度更快。

---
### 联合索引的B+树索引是怎么设置存储的？
非叶子节点是第一个索引的顺序，在叶子节点上data域是按每个索引的顺序排列。并且叶子节点上存放对应的主键记录的地址。

---
### 联合索引什么时候失效？
1. 没有遵循最左匹配原则
2. 用or连接

---
### 影响查询性能瓶颈的因素

---
### 如何定位慢sql、具体命令 (show process)里面包含了线程ID等等

---
### 遇到过一句sql执行很慢的场景吗？如何解决的？

---
### 慢查询sql应该如何排查？如何优化？
1. 确认慢查询的原因：确认是哪些sql语句导致了慢查询，可以使用mysql的**慢查询日志**（slow query log）来查看；
2. 分析查询执行计划：使用explain命令来分析查询执行计划（会给出查询类型、表的连接方式、使用的索引信息），
确定查询语句的优化方向；关注type(访问类型all全表扫描index索引扫描range范围扫描)、key(实际使用的索引)、rows(扫描的行数)、extra(比如using filesort、using temporary)
3. 优化查询语句：通过优化查询语句（比如添加索引、使用合适的查询语句等）来提高查询性能
4. 调整mysql参数：可以通过调整mysql的参数（如缓存大小、连接数（mysql使用连接池））来提高查询性能
5. 拆分大查询：对于大查询语句，可以考虑拆分成多个小查询语句（分页查询、分区查询、并行查询），以减少查询负载
6. 使用缓存：使用缓存避免重复查询，提高查询性能

---
### sql使用应该注意哪些事项？

1. 索引的合理使用
- 创建必要的索引：为经常查询、排序、join的列创建索引；
- 避免过多索引：会增加写操作负担；
- 尽量设计覆盖索引覆盖所需的所有字段，减少回表操作
2. 查询时：
- 尽量使用=而不是like或in这种可能导致全表扫描的操作符
- 使用limit限制返回的结果数量，特别在分页查询中
- 避免select *，只返回需要的列，避免全表扫描
3. 避免在索引上使用函数
4. 尽量保持事务简短，减少锁定时间
5. 使用批量插入/更新
6. 大表考虑使用分区表

---
### mysql部署方式有哪些？
1. 单机部署：
2. 主从部署
3. 分布式部署
4. 集群部署

---
### 如何使用读写分离(解决读高并发)和分库分表(解决存储压力)提高查询性能
1. 读写分离
- 首先使用主从架构部署多台MySQL服务器，
- 第二步实现主从复制，
- 第三步把写请求发到主服务器，读请求分发到从服务器。

主写从读，会带来主从不一致问题

2. 分库分表：将大表拆分成多个小表，分为水平分表、垂直分表

---
### MySQL多机高可用方案
1. 使用主从复制架构

---
### 主从复制过程
1. 主库接收到客户端的更新，写数据到binlog
2. 主库创建binlog dump线程，把binlog发送到从库，从库创建IO线程，接收binlog
3. 从库IO线程接收binlog后写入到relay log文件中
4. 从库创建SQL线程读取relay log同步数据

---
### 分库分表如何实现
- 垂直分表：把一个列数比较多的表拆分为多个表；
- 水平分表：把一个行比较多的表拆分成多个表；(按某种规则比如用户id、时间戳)将数据划分到不同的表中。

数据水平分片之后，通过分片算法决定存放在那个表中。也可以使用中间件(ShardingSphere，MyCat，Vitess)
- 哈希分片
- 范围分片
- 地理位置分片
- 融合分片

分表后带来的问题是join连接比较麻烦，事务操作无法保证，如何生成全局唯一的主键id(UUID、雪花算法、redis生成ID)

> 雪花算法:一种分布式ID生成算法，64位整数 1位符号位+41位时间戳+10位机器ID+12位序列号

---
### redo log，undo log，Read View，两阶段提交，MVCC 机制？

---
### mysql提供了哪些机制实现事务？
1. ACID特性
2. START TRANSCATION或BEGIN
3. COMMIT
4. ROLLBACK
5. SAVEPOINT
6. 事务隔离级别
7. 锁机制保证事务的隔离性
8. 多版本并发控制MVCC实现多个事务同时对同一数据进行修改的情况，每个事务都可以看到一个数据的副本
9. 事务日志：使用事务日志来记录事务的所有操作，如果系统崩溃，可以使用事务日志来恢复数据。

---
### 检查两个表数据是否一致，找出不一致的数据

1. 左右join找缺失

```roomsql
select a.*
from a 
left join b
on a.id = b.id
where b.id is NULL;
```

2. 全外连接full join
既要找缺失，又要比对字段值。相同id的记录还要保证name和age相同。
```roomsql
select coalesce(a.id, b.id) as id
from a
full join b
on a.id = b.id
where a.id is NULL or b.id is NULL or a.name != b.name or a.age != b.age;

```

3. union all+计数法

```roomsql
select id, name, count(*) as cnt
from (
select id, name
fram a 
union all 
select id, name
from b
) tmp
group by id, name
having cnt != 2;
```

---
### sql开窗，group by不聚合操作怎么得到其他字段
聚合函数每组只返回一个值，开窗函数每组可以返回多个值。

---
### 窗口函数
1. 聚合类的窗口函数,聚合类的函数也可以用在普通的创建
 - SUM()     SUM(salary) OVER(PARTITION BY department_name) AS total_salary,   当前行所在部门的总薪水
 - AVG()    AVG(salary) OVER(PARTITION BY department_name) AS average_salary,
 - COUNT()  COUNT(*) OVER(PARTITION BY department_name) AS employee_count,
 - MAX()    MAX(salary) OVER(PARTITION BY department_name) AS max_salary,
 - MIN()   MIN(salary) OVER(PARTITION BY department_name) AS min_salary,
2. 排名函数
 - ROW_NUMBER()
 - RANK()
 - DENSE_RANK()
3. 取值窗口函数 (下面几个都必须在函数里面指定作用的列名)
 - LAG():访问当前行之前的第n行数据   LAG(salary, 1, 0) OVER(PARTITION BY department_name ORDER BY salary DESC) AS prev_salary : 返回在部门内前一个薪资高的员工工资，如果没有返回0
 - LEAD()：访问当前行之后的第n行数据  
 - FIRSR_VALUE()：获取窗口内第一行的值  FIRST_VALUE(salary) OVER(PARTITION BY department_name ORDER BY salary DESC) AS max_salary_in_department 返回每个部门薪资最高的员工
 - LAST_VALUE()：获取窗口内最后一行的值
 - NTH_VALUE()：获取窗口内第n行的值，如果存在多行则返回第一个
4. 分布窗口函数
 - PERCENT_RANK():计算每一行的相对排名，返回一个介于0到1之间的值，表示当前行在分区中的排名百分比
 - CUME_DIST():计算小于或等于当前行的行数占窗口总行数的比例
5. 分组窗口函数
 - NTILE():将窗口内的行分为指定数量的组，每组的行数尽可能相等，返回当前行在第几组。 NTILE(4) OVER(PARTITION BY department_name ORDER BY salary DESC) AS salary_quartile 每个部门都分成4组
 
**例子：**
1. ROW_NUMBER() 是窗口函数， 后面over()里面的是函数作用的窗口，这里的窗口相当于是按Total列排序后的整张表，
row_number()函数的作用就是为排序后的窗口里的每一行分配一个序号。所以最后的结果是按total排名的意思。
```roomsql
select Gender, Name, Total,
      ROW_NUMBER() OVER(ORDER BY Total DESC) AS Popularity
from baby_names;
```
上面的窗口是整个排序后的整个表，下面的窗口是按Gender列分区的多个窗口

```roomsql
select Gender, Name, Total,
       ROW_NUMBER() OVER(PARTITION BY Gender ORDER BY Total DESC) AS Popularity
from baby_names;
```

2. RANK(),DENSE_RANK():放回当前行在窗口内的排序，需要配合ORDER BY对分区内的所有行排序

```roomsql
select Gender, Name, Total,
       ROW_NUMBER() OVER(ORDER BY Total DESC) AS Popularity,
       RANK() OVER(ORDER BY Total DESC) AS Popularity_R,
       DENSE_RANK() OVER(ORDER BY Total DESC) AS Popularity_DR
from baby_names;
```

---
### HDFS、MapReduce/Spark、YARN、HIVE的关系
Hive是数据仓库工具，负责定义表结构、管理元数据、把sql转化为计算任务来操作HDFS数据

Hive（翻译 SQL）→ YARN（调度资源）→ 计算引擎（MapReduce/Spark）→ HDFS（通过 NameNode/DataNode 存取数据）。

---
### HDFS和Hive的区别
1. HDFS只负责管理文件的存储位置和分块，是分布式文件存储系统，有NameNode和DataNode
2. Hive负责文件内部的数据组织和解析方式，负责数据的格式化方式、行存储还是列存储、压缩格式等

---
### Hive的存储格式有哪些？
hive.default.format配置存储格式，默认是Text file

--- 
### ORC和Parquet的主要区别是什么？
都是列式存储，只查询需要的列信息。

---
### 谓词下推如何提高查询性能？
有不同级别的统计信息，可以跳过数据

---
### 什么时候选择Avro而不是列式存储格式？

---
### 行存和列存的区别?
- 列存储，因为数据集都是同一列的，数据类型一致，所以数据解析过程快，有利于分析大数据；
- 列存储，因为相同的列放在一起，所以可以用压缩算法压缩数据，不同列用不同的压缩算法。压缩之后IO性能会提升。

> 所以数据写入时，行存储高效；数据读取以及传输时，列存储高效

---
### 分库分表怎么做的？扩容的话怎么做？

---
### 分库分表的跨节点join查询

---
### 两张表：一张是每天的视频播放量记录，一张是视频的标签关系表，问过去一周每个标签下播放量最高的视频。

---
### 数据库主从延迟有什么办法缓解吗？

---
### sql having？
- having是在聚合后进行过滤，where是在聚合前过滤行数据；
- 可以使用count，sum函数

例子：
查询平均成绩大于80分的班级
```roomsql
SELECT class_id, AVG(score) AS avg_score
FROM students
GROUP BY class_id
HAVING AVG(score) > 80;  -- 筛选分组后的平均值
```

查询每个部门中薪资总和超过 100 万且人数超过 5 人的分组
```roomsql
SELECT department, position, SUM(salary) AS total_salary, COUNT(*) AS emp_count
FROM employees
GROUP BY department, position
HAVING total_salary > 1000000 AND emp_count > 5;
```

查询订单数超过 3 且总金额超过 1000 的客户。
```roomsql
SELECT customer_id, COUNT(order_id) AS order_count, SUM(amount) AS total_amount
FROM orders
GROUP BY customer_id
HAVING order_count > 3 AND total_amount > 1000;
```

---
### 如果数据库连接池有500连接，但高流量达到了上万，如何处理？乐观锁的问题是什么？限流之外是否有其他解决方案？

---
### mysql连接池
功能：
1. 连接复用
2. 控制最大连接数
3. 自动重连和恢复
4. 监控管理

```yaml
spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      initial-size: 30 #初始化时建立物理连接的个数
      max-active: 50 #连接池最大连接数
      min-idle: 30 # 连接池中最小空闲连接数
      max-wait: 6000 #获取连接最大等待时间，单位毫秒
      query-timeout: 300000 #查询超时时间，单位毫秒
      validation-query: SELECT 1 FROM DUAL #验证数据库服务可用性的查询SQL
      pool-prepared-statements: true #标识位。是否开启预编译SQL，即PSCache
      test-while-idle: true #从连接池获取连接后，如果超过被空闲剔除周期，是否做一次连接有效性检查
      test-on-borrow: false #从连接池获取连接后，是否马上执行一次检查
      test-on-return: false #归还连接到连接池时是否马上做一次检查
      keep-alive: true #是否开启连接保活
      time-between-eviction-runs-millis: 60000 #周期性剔除长时间呆在池子里未被使用的空闲连接, 1 min 一次
```

---
### 执行UPDATE语句时，锁是加在线程还是数据库对象上？
加载数据表或行记录上，如果查询条件命中索引的话，锁是行级锁，会加临键锁；如果没有命中索引，则是表级锁；

---
### SQL优化:select * from table where a > ? and b = ? or c = ? order by d decs limit 10
1. 不要用select * ，要列出想要的列；
2. 不要用or，可以用两个查询，然后union all
3. 创建覆盖索引，覆盖查询条件
4. 最后改完后，用explain查看，重点看key列和extra列
5. 虽然在where条件里a排在前面，但是a是范围查询，sql优化器会先判断b和c，再判断a条件，所以创建索引的时候应该bc在前，a在后面

> 最后创建的两个联合索引是(b,d,a,c)和(c,d,a,b)。

---
### sql实现，实现一个死锁情况，必须是必然发生
- 创建两个事务，一个事务先更新id=1的记录，再随眠几秒，然后更新id=2的记录；
- 另一个事务先更新id=2的记录，再随眠几秒，然后更新id=1的记录；

---
### mysql 行转列？ 列转行？
1. 行转列
```roomsql
SELECT userid,
SUM(CASE `subject` WHEN '语文' THEN score ELSE 0 END) as '语文',
SUM(CASE `subject` WHEN '数学' THEN score ELSE 0 END) as '数学',
SUM(CASE `subject` WHEN '英语' THEN score ELSE 0 END) as '英语',
SUM(CASE `subject` WHEN '政治' THEN score ELSE 0 END) as '政治' 
FROM tb_score 
GROUP BY userid
```
2. 列转行
```roomsql
SELECT userid,'语文' AS course,cn_score AS score FROM tb_score1
UNION ALL
SELECT userid,'数学' AS course,math_score AS score FROM tb_score1
UNION ALL
SELECT userid,'英语' AS course,en_score AS score FROM tb_score1
UNION ALL
SELECT userid,'政治' AS course,po_score AS score FROM tb_score1
ORDER BY userid
```
