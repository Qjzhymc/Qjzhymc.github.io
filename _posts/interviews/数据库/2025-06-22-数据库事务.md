---
title: 数据库事务
author: Yu Mengchi
categories:
  - Interview 
  - 面试知识点
  - 数据库
tags:
  - Interview
  - DataBase
---

---
### MySQL如何支持事务的？一个事务的执行流程是什么样的？如何把一组操作作为事务提交执行？事务回滚是如何回滚的？事务的ACID特性是什么？
如何支持事务：
1. MySQL通过InnoDB存储引擎支持事务。

事务执行流程：
1. 开始事务：通过START TRANSACTION或BEGIN语句开启一个新的事务；
2. 执行sql操作：在事务中执行一系列的SQL语句，比如INSERT、UPDATE、DELETE，这些操作不会立即执行，而是暂时保存在事务日志中；
3. 提交事务：如果所有操作都成功完成，则使用COMMIT命令将事务所做的更改永久同步到数据库中；
4. 回滚事务：如果有任何错误，可以使用ROLLBACK命令撤销事务中的所有操作。

事务如何回滚：
1. 事务执行的时候会把修改的数据、修改前后的值、操作的时间戳信息存放在事务日志里；
2. 所以回滚的时候，会从事务日志里找到所有记录，包含事务对数据库做的所有操作；
3. 然后，数据库系统按照事务日志记录的逆序进行反向操作。

事务的ACID特性：
1. 原子性：原子性表示事务是最小的执行单元，一个事务内的所有操作要么全部成功执行，要么全部不执行。
 - 实现方式：日志(undo log)
2. 一致性：事务必须使数据库从一种一致状态转换为另一种一致状态。不会破坏数据库的完整性约束；主键约束、外键约束、唯一约束；
3. 隔离性：多个并发事务之间相互独立、互不影响；
 - 四种隔离级别
4. 持久性：一个事务被提交之后，对数据库内的数据的改变应该是永久性的，即使数据库发生故障也不应该影响执行结果。
 - 实现方式：redo log

MySQL事务原理：
1. 通过undo log保证回滚，实现事务的原子性
2. 通过redo log实现故障后恢复，实现事务的持久性
3. 通过锁机制和MVCC实现隔离性，共享锁(读锁)，排他锁(写锁)
4. 最终保证一致性

acid特性怎么实现的：
事务、锁机制、日志

并发事务带来的问题：
1. 脏读：一个事务对数据修改，但是还没有提交，这时另一个事务读到了未提交的数据，之后第一个事务又回滚了，导致第二个事务读到的数据是错误的。
2. 不可重复读：一个事务修改数据，另一个事务同时读取两次数据，前后两次读取可能会因为第一个事务的修改导致读取结果不一致。
3. 幻读（Phantom read）：一个事务多次读取同一个数据时，由于另一个事务同步修改，导致多次读取的记录条数不一致，重点是读取的记录条数不一致，和不可重复读类似，不可重复读的重点是多次读取的记录的值不一致。想要解决幻读，重点是要防止一个事务在读取数据的时候另一个事务删除或新增数据。

事务的四种隔离级别：
1. 读未提交（read uncommitted）：最低的隔离级别，允许读取未提交事务的数据变更，会导致脏读、幻读、不可重复读；
2. 读已提交(read committed)：并发事务只能读取其他事务已经提交的修改，只可以防止脏读，幻读和不可重复读仍然有可能发生；
3. 可重复读(repeatable-read)：InnoDb的默认隔离级别。保证同一个事务里面可以多次读取的数据是一致的，除非是自己修改的。可以防止脏读和不可重复读问题，但是幻读还是有可能；所以InnoDB在这个隔离级别下使用MVCC+Next Key Lock防止幻读
4. 串行化(serializable)：所有事务串行执行。最高的隔离级别，可以防止脏读、不可重复读和幻读。

Next-Key Lock：这是InnoDB默认的锁定策略，结合了**行锁+间隙锁**。
- 行锁：锁定具体的行数据
- 间隙锁：锁定索引之间的间隙，防止其他事务在这些间隙中插入新数据

通过Next-Key Lock，InnoDB能够锁定查询范围内的所有现有数据行以及潜在的插入位置，从而防止其他事务在这些范围内插入新数据。可以避免幻读。

---
### MVCC在InnoDB中是如何实现的？MVCC的原理
在MVCC中，每个事务在读取数据时会看到一个独立的快照版本，而不是看到其他并发事务正在修改的版本。这个快照版本是通过在每个数据行上添加隐藏的事务版本号来实现的。

**底层实现：** 通过undo log版本链和ReadView机制来实现。**undo log保存历史快照，readView可见性规则帮助判断读取哪个版本的数据。**
1. Undo log版本链：每行数据保存多个历史版本，通过事务ID和回滚指针连接
 - 每次更新数据，会生成一个新数据版本，让其指向上一个版本，老版本数据不会丢，可以通过Undo Log版本链找到；
2. readView：事务开始时生成的快照，决定当前事务能看到哪些版本的快照。
 - 每次读取数据，会生成一个ReadView，根据readView的可见性规则判断哪个版本的数据对当前事务可见。

---
### MVCC如何保证事务可见
1. MVCC为每个事务创建一个快照来解决多个事务同时访问数据库带来的数据不一致性和读写冲突。
2. 事务开始时，会获得一个当前快照的视图，该视图显示了在该事务开始之前对数据库进行的所有更改。
3. 然后，当该事务对数据库进行更改时，这些更改将在快照中创建一个新版本的数据。其他事务将继续使用它们开始时获得的视图，
4. 即使在更改进行时，它们也不会看到新版本的数据，这样，每个事务都可以在自己的版本中查看数据，并且不会相互干扰，从而确保事务的可见性。

---
### 并发事务控制方式有哪些？
- 锁： 写锁和读锁
- MVCC：多版本并发控制，对一份数据存储多个版本，通过事务的可见性保证事务能看到自己应该看到的版本，
  通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。

---
### 可重复读事务隔离级别的实现原理？
- 读取数据的时候，事务对当前被读取的数据不加锁，并且是快照读，读取事务开始时的数据快照，不是最新数据，通过MVCC实现；
- 更新数据的时候，事务在更新数据的瞬间，必须对数据加行级排它锁（record lock,gap lock,next-key lock）,直到事务结束才释放。

---
### mysql有哪些锁，间隙锁是什么？
1. 行级锁有：
- 记录锁(record locks): 锁定查找到的记录行
- 间隙锁(gap locks): 锁定一个范围，但是不包括行本身，防止其他事务在这个范围内插入新记录，所以其他事务还是可以更新已有的记录、查询已有的记录的。用于可重复读隔离级别下，避免幻读问题；
- next-key locks: 是记录锁和间隙锁的结合，用于防止其他事务在这个范围内插入、更新、删除操作。

2. 表级锁有：
- 意向共享锁(Intention Shared Lock,IS):表示事务打算对表中的某些行设置共享锁；
- 意向排他锁(Intention Exclusive Lock, IX):表示事务打算对表中的某些行设置排他锁；
- 共享锁(Shared Lock,S):允许事务读取一行，多个事务可以同时持有同一行的共享锁；
- 排他锁(Exclusive Lock, X): 允许事务删除或更新一行，只有一个事务可以获取某一行的排他锁。

3. 间隙锁是什么？
   间隙锁是InnoDB存储引擎在可重复读隔离级别下使用的一种锁机制。主要用来解决幻读问题，幻读就是指在一个范围内执行相同的两次查询时，可能会发现由于有新插入的行导致两次查询结果集不同。
- 间隙锁的作用就是它不会锁定特定的记录，而是锁定两个记录之间的间隙，防止其他事务在这个间隙内插入新记录；
- 可以防止幻读，保证了事务的隔离性。

---
### 快照读和当前读
是两种不同的读取机制
1. 快照读：读取事务开始时的数据快照，不是最新数据，通过MVCC实现，每个事务读取自己可见的版本，不会锁定数据，可能读到旧数据。在RR隔离级别下，select默认是快照读
2. 当前读：读取最新提交的数据，对读取的数据加锁，
- 排他锁 SELECT ... FOR UPDATE、UPDATE、DELETE都是排他锁
- 共享锁 SELECT ... LOCK IN SHARE MODE

---
### 乐观锁和悲观锁
1. 悲观锁假设并发访问概率很高，会对资源进行锁定防止其他线程对它修改。实现悲观锁：表锁、行锁。
2. 乐观锁假设并发访问概率较低，采用版本号或时间戳的方式来控制并发修改。实现乐观锁：在数据表中添加一个版本号字段或时间戳字段，每次更新数据时都会将版本号或时间戳加1，当提交数据时，检查当前版本号或时间戳是否和提交前一致，如果一致则提交成功，否则回滚。
3. 悲观锁适用在改动频繁的情况，乐观锁适用于读多写少的场景。

悲观锁实现：表锁、行锁
1. SELECT ... FOR UPDATE:排他锁
   用上面语句执行查询时，会对查询结果的每一行加上排他锁，直到当前事务结束
```roomsql
START TRANSACTION;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;
```

2. SELECT ... LOCK IN SHARE MODE:共享锁
   会给查询到的行加共享锁，其他事务也可以加共享锁但是不能加排他锁，适用于只读场景。
3. LOCK TABLES accounts WRITE;表级锁

> 还可以不用sql语句加锁，可以在应用层加锁，在redis上设置一个锁，可以使用redis的分布式锁。
