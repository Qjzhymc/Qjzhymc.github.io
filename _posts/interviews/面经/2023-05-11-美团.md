---
title: 美团面试题
author: Yu Mengchi
categories:
  - Interview
  - 面经
tags:
  - Interview
  - 面经
---

### Spring AOP底层原理

aop底层是通过动态代理机制实现的，
- 如果要代理的对象，实现了某个接口，spring AOP会使用JDK Proxy，去创建代理对象。
- 如果没有实现接口的对象，会使用Cglib生成一个被代理对象的子类来作为代理。

### HashMap的底层数据结构是怎样的？

HashMap包含一个Entry类型的数组table，entry存储键值对，主要包含四个字段hashcode，k，v，next；数组中每个位置当成一个桶，
使用拉链法解决hash冲突。每插入一个Entry对，通过hash运算计算桶下标
扩容基本原理：当需要扩容时，table扩大两倍，重新计算桶下标，
从jdk1.8开始，一个桶的链表长度超过8时会将链表转化为红黑树。

### HashMap的扩容机制是怎样的？

HashMap会有一个阈值，当元素数量超过阈值就会触发扩容，每次扩容的容量都是之前容量的2倍。这个阈值的大小一般是容量*负载因子。
 
- 如果是通过空参数构造函数创建HashMap的话，第一次调用put方法的时候会开始第一次初始化扩容，长度为16。
- 如果是通过有参构造函数创建HashMap的话，会根据参数指定容量。

### ConcurrentHashMap的存储结构是怎样的？

在java7中是使用分段锁，首先有一个Segment数组，每一个Segment上都有一个类似HashEntry数组的结构，如果要对HashEntry数组里的元素修改的话，首先要获得对应的Segment锁。
在Java8中就没有了Segment的概念，直接用Node数组+链表+红黑树的结构来实现，并发控制的话使用Synchronized和CAS来操作，结构类似于HashMap。

### 线程池大小如何设置？

应该根据任务特点分类吧，
- 如果是CPU密集型任务，应该线程数设置为N+1，防止有些原因导致任务暂停，CPU处于空闲状态，多一个线程就可以充分利用CPU的空闲时间。
- 如果是IO密集型任务，系统大部分时间都用来处理IO交互，可以多配置一些线程，一般是设置为2*N。

> 什么样的任务是CPU密集型任务，什么是IO密集型任务呢？需要很多计算能力的就是CPU密集型任务，比如需要在内存中对大量数据排序；如果是涉及到网络读取、文件读取就是IO密集型任务。


### G1垃圾收集器有哪些特点？

G1收集器会在后台维护一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的区域。

- 并发能力强，可以使用多个CPU来缩短STW停顿时间。
- 分代收集
- 空间整合能力强，
- 可以预测停顿时间

### 如何排除OOM的问题？（内存溢出）

- 可以设置jvm运行参数，当发生OOM的时候自动dump堆内存信息到指定的目录。
- 然后通过内存分析工具载入dump文件，分析大对象的占用情况，比如会有一些缓存没有及时清理，时间长了就会发生内存溢出。
- 另外可以通过jstat查看监控jvm的内存和GC情况，可以先观察问题大概出现在什么区域。

### MySQL事务隔离级别，默认的隔离级别是什么？

- 读未提交：事务可以读取到其他未提交事务修改的数据。
- 读已提交：只能读取到已经提交的事务的数据
- 可重复读：对同一字段的多次读取结果都是一致的，除非数据是被自身所修改的。
- 串行化：所有的事务逐个执行，完全不会产生干扰

> mysql默认采用的是可重复读隔离级别

### 可重复读解决了哪些问题？

可重复读解决了脏读、不可重复读的问题。

### 对SQL慢查询会考虑哪些优化？

- 分析sql语句，是不是加载了不必要的字段或数据
- 可以用explain分析sql的执行计划，查看有没有命中索引
- 分析表结构和索引信息，分析sql语句，是不是很复杂，考虑优化sql结构
- 如果表数据量太大，考虑分表

### 缓存穿透、缓存击穿、缓存雪崩，以及解决办法？

- 缓存穿透：就是大量并发查询的key在缓存和数据库中都不存在，对缓存服务和数据库都会造成压力。一般是服务收到DDoS攻击，或者业务数据被删除。
一般解决的话可以通过布隆过滤器存放所有的key，查询先经过布隆过滤器，如果不存在的话，就不再缓存和数据库中查询；另外就是在处理请求前判断该请求是不是合理的，增加恶意请求检测，如果是不合理的就拒绝服务。

- 缓存击穿：就是某个热点key失效的时候，正好有大量的并发请求访问这个key，导致查询直接大量访问数据库。一般是热点key的业务活跃期间过期导致的。
一般解决的话可以设置热点key用不过期。

- 缓存雪崩：就是指某一个时刻发生大规模的缓存失效的情况，导致大量的请求无法获取数据，导致数据库压力过大。一般原因是大量的数据在同一时间失效，或者缓存服务宕机了。
一般解决的话就是在分散数据的过期时间，不要在同一时间过期。对于缓存服务要提供高可用能力，使用多台机器做主从部署，保证有多个副本能提供服务。

### LRU是什么？如何实现？

LRU是最近最少使用策略，是一种缓存淘汰机制。
