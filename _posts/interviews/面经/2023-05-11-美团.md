---
title: 美团面试题
author: Yu Mengchi
categories:
  - Interview
  - 面经
tags:
  - Interview
  - 面经
---

### Spring AOP底层原理

aop底层是通过动态代理机制实现的，
- 如果要代理的对象，实现了某个接口，spring AOP会使用JDK Proxy，去创建代理对象。
- 如果没有实现接口的对象，会使用Cglib生成一个被代理对象的子类来作为代理。

### HashMap的底层数据结构是怎样的？

HashMap包含一个Entry类型的数组table，entry存储键值对，主要包含四个字段hashcode，k，v，next；数组中每个位置当成一个桶，
使用拉链法解决hash冲突。每插入一个Entry对，通过hash运算计算桶下标
扩容基本原理：当需要扩容时，table扩大两倍，重新计算桶下标，
从jdk1.8开始，一个桶的链表长度超过8时会将链表转化为红黑树。

### HashMap的扩容机制是怎样的？

HashMap会有一个阈值，当元素数量超过阈值就会触发扩容，每次扩容的容量都是之前容量的2倍。这个阈值的大小一般是容量*负载因子。
 
- 如果是通过空参数构造函数创建HashMap的话，第一次调用put方法的时候会开始第一次初始化扩容，长度为16。
- 如果是通过有参构造函数创建HashMap的话，会根据参数指定容量。

### ConcurrentHashMap的存储结构是怎样的？

在java7中是使用分段锁，首先有一个Segment数组，每一个Segment上都有一个类似HashEntry数组的结构，如果要对HashEntry数组里的元素修改的话，首先要获得对应的Segment锁。
在Java8中就没有了Segment的概念，直接用Node数组+链表+红黑树的结构来实现，并发控制的话使用Synchronized和CAS来操作，结构类似于HashMap。

### 线程池大小如何设置？

应该根据任务特点分类吧，
- 如果是CPU密集型任务，应该线程数设置为N+1，防止有些原因导致任务暂停，CPU处于空闲状态，多一个线程就可以充分利用CPU的空闲时间。
- 如果是IO密集型任务，系统大部分时间都用来处理IO交互，可以多配置一些线程，一般是设置为2*N。

> 什么样的任务是CPU密集型任务，什么是IO密集型任务呢？需要很多计算能力的就是CPU密集型任务，比如需要在内存中对大量数据排序；如果是涉及到网络读取、文件读取就是IO密集型任务。


### G1垃圾收集器有哪些特点？

G1收集器会在后台维护一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的区域。

- 并发能力强，可以使用多个CPU来缩短STW停顿时间。
- 分代收集
- 空间整合能力强，
- 可以预测停顿时间

### 如何排除OOM的问题？（内存溢出）

- 可以设置jvm运行参数，当发生OOM的时候自动dump堆内存信息到指定的目录。
- 然后通过内存分析工具载入dump文件，分析大对象的占用情况，比如会有一些缓存没有及时清理，时间长了就会发生内存溢出。
- 另外可以通过jstat查看监控jvm的内存和GC情况，可以先观察问题大概出现在什么区域。

### MySQL事务隔离级别，默认的隔离级别是什么？

- 读未提交：事务可以读取到其他未提交事务修改的数据。
- 读已提交：只能读取到已经提交的事务的数据
- 可重复读：对同一字段的多次读取结果都是一致的，除非数据是被自身所修改的。
- 串行化：所有的事务逐个执行，完全不会产生干扰

> mysql默认采用的是可重复读隔离级别

### 可重复读解决了哪些问题？

可重复读解决了脏读、不可重复读的问题。

### 对SQL慢查询会考虑哪些优化？

- 分析sql语句，是不是加载了不必要的字段或数据
- 可以用explain分析sql的执行计划，查看有没有命中索引
- 分析表结构和索引信息，分析sql语句，是不是很复杂，考虑优化sql结构
- 如果表数据量太大，考虑分表

### 缓存穿透、缓存击穿、缓存雪崩，以及解决办法？

- 缓存穿透：就是大量并发查询的key在缓存和数据库中都不存在，对缓存服务和数据库都会造成压力。一般是服务收到DDoS攻击，或者业务数据被删除。
一般解决的话可以通过布隆过滤器存放所有的key，查询先经过布隆过滤器，如果不存在的话，就不再缓存和数据库中查询；另外就是在处理请求前判断该请求是不是合理的，增加恶意请求检测，如果是不合理的就拒绝服务。

- 缓存击穿：就是某个热点key失效的时候，正好有大量的并发请求访问这个key，导致查询直接大量访问数据库。一般是热点key的业务活跃期间过期导致的。
一般解决的话可以设置热点key用不过期。

- 缓存雪崩：就是指某一个时刻发生大规模的缓存失效的情况，导致大量的请求无法获取数据，导致数据库压力过大。一般原因是大量的数据在同一时间失效，或者缓存服务宕机了。
一般解决的话就是在分散数据的过期时间，不要在同一时间过期。对于缓存服务要提供高可用能力，使用多台机器做主从部署，保证有多个副本能提供服务。

### LRU是什么？如何实现？

LRU是最近最少使用策略，是一种缓存淘汰机制。

### 什么是堆内存？参数如何设置？

在java中，堆内存主要用于分配对象的存储空间。
- Xmx，指定最大堆内存
- Xms，指定堆内存空间的初始大小
- Xss，设置每个线程栈的大小，

### 栈和队列，举个使用场景例子？

- 栈可以用于字符匹配、数据反转场景
- 队列可以用于任务队列、共享打印机等场景

### MySQL为什么InnoDB是默认引擎？


### MySQL索引底层结构为什么使用B+树？
可以支持范围查询和排序，叶子节点之间通过指针相互连接。

### B+树的叶子节点链表是单向还是双向？
双向链表

### MVCC是什么？它的底层原理是什么？

MVCC是多版本并发控制，通过读取历史版本的数据，来降低并发事务冲突，提高并发性能的一种机制。

- 事务版本号
- 表的隐藏列
- undo log
- read view

### undo log具体怎么回滚事务？

对于insert、delete、update类型的sql，会在undo log中记录修改之前的数据，当回滚的时候，反向执行修改的操作就可以。

### 如何查询慢sql产生的原因？

- 分析sql的执行计划，看有没有命中索引
- 如果没有用到索引，可能就是索引设计，或者sql语句有问题。需要优化sql语句，或者重新加索引
- 看看是不是查询出的数据量过大，是不是返回了不必要的行或列。

### 索引失效的情况有哪些？

- like已%开头，索引会失效
- or语句前后没有同时索引，也会失效
- 组合索引的时候，使用的不是第一列索引的时候，会失效
- 数据类型出现隐式转换
- 对索引字段使用了函数操作
- 在索引列上使用is null或者is not null的时候
- 在索引字段上使用not、<>、！=的时候会失效。

### 一个redis实例最多能存放多少的keys？list、set、sorted set它们最多能存放多少元素？

一般内存值有多少就可以存放多少？

### redis数据结构？压缩列表和跳跃表的区别？


### 为什么数据量小的时候用压缩列表？


### redis主从同步是怎么实现的？

redis主从刚刚建立连接的时候，会进行全量同步；全量同步结束后，进行增量同步。

- 在全量同步的时候主服务器会开启一个后台进程用于将redis中的数据生成一个rdb文件，同时，会缓存所有写命令。rdb文件生成之后会发送给从服务器，从服务器根据rdb文件将数据加载到内存，同时主服务器缓存的写命令也会传给从服务器，
然后从服务器将这些命令依次作用于自己本地的数据集上最终达到数据的一致性。

- 在增量同步的时候，主服务器会在内存中给每个从服务器维护一份同步日志和同步标识。每个从服务器和主服务器同步时候都会携带自己的同步标识和上次同步的最后位置，根据这些标识，主服务器把之后的指令发送给从服务器，进行增量同步。

### redis持久化rdb和aof优缺点？

rdb是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。
优点是：
- 保存了某个时间点的数据，适合做数据备份；
- rdb文件比较紧凑，方便传输
- rdb过程是有子进程处理的，不会影响redis的性能。
- 在恢复大数据集的时候，rdb比aof快一些。

缺点是：
- redis意外宕机的话，会丢失部分数据



aof是将执行过的写指令记录下来，在数据恢复的时候从前到后再将指令都执行一边。

优点是：
- aof可以根据fsync策略方便持久化。比如每秒写入磁盘一次
- aof文件是只进行追加的日志文件，不需要在写入时读取文件
- redis可以在aof文件体积较大的时候，进行aof重写
- 可读性高，容易分析

缺点是：
- aof文件量比rdb文件大


### 谈谈自己对Spring AOP的了解？

AOP是指面向切面编程，可以将一些业务模块共同调用的逻辑封装起来，比如事务处理、日志管理、权限控制这些。可以减少系统的重复代码，降低模块间的耦合度。

### Spring Bean容器的生命周期是什么样的？

首先会实例化bean对象-
然后设置对象属性-
检查bean有没有实现一些Aware接口，比如设置bean的name，设置bean的classLoader，设置bean的beanFactory，设置这些依赖-
然后进行beanPostProcessor前置处理-
检查bean有没有实现initializingBean接口，执行afterPropertiesSet()方法-
检查是否有自定义的init方法-
进行beanPostProcessor后置处理-
当要销毁的时候，如果bean实现了DisposableBean接口，执行destroy()方法-
最后调用自定义的destroy方法。

> 实例化-属性赋值-初始化-销毁


