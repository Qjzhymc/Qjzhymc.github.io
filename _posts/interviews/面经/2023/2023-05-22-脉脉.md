---
title: 脉脉面试题
author: Yu Mengchi
categories:
  - Interview
  - 面经
tags:
  - Interview
  - Redis
---
  
### 元空间受jvm内存影响吗？
- 堆外内存：元空间不在jvm堆内存里，在本地内存中，不会影响到堆内存的使用。
- 但是还是可以通过设置jvm参数设置元空间大小的，-XX:MaxMetaSpaceSize。
- 元空间是在java 8中引入的，用于替换永久代，主要用来存储类的元数据，比如类名、接口名列表、常量池等。
- 如果没有类加载器引用某个类的时候，这个类的元数据也是可以被垃圾回收的。

> 方法区是规范。永久代和元空间都是实现。 
> 在jdk1.8之前，方法区的实现是用永久代；在jdk1.8之后，方法区的实现是用元空间，并且不再使用虚拟机内存而是本地内存。

---
### thrift用的网络传输协议是什么？
thrift可以选不同的传输层协议，
- TBinaryProtocal：使用二进制对数据序列化和反序列化，很高效，适合大部分场景；
- TCompactProtocal：会对数据进行压缩，也是二进制形式，传输的数据量会更小；
- TJSONProtocal：使用JSON对数据序列化和反序列化，跨语言兼容性更好；
- TSimpleJSONProtocal：只支持写操作的JSON协议。

上面的协议是指数据如何被序列化和反序列化，数据怎么在网络之间传输，thrift也有不同的传输层协议：
- TSocket：基于TCP/IP的传输协议，阻塞式的；
- TFramedTransport：用固定大小的帧，来表示发送和接收的数据的；
- TFileTransport：用于文件读写的传输方式；
- TMemoryTransport：内存中的传输，用于进程间通信；
- TZlibTransport：提供压缩功能的传输层。

---
### mysql有哪些锁，间隙锁是什么？
1. 行级锁有：
 - 记录锁(record locks): 锁定查找到的记录行
 - 间隙锁(gap locks): 锁定一个范围，但是不包括行本身，防止其他事务在这个范围内插入新记录，所以其他事务还是可以更新已有的记录、查询已有的记录的。用于可重复读隔离级别下，避免幻读问题；
 - next-key locks: 是记录锁和间隙锁的结合，用于防止其他事务在这个范围内插入、更新、删除操作。

2. 表级锁有：
 - 意向共享锁(Intention Shared Lock,IS):表示事务打算对表中的某些行设置共享锁；
 - 意向排他锁(Intention Exclusive Lock, IX):表示事务打算对表中的某些行设置排他锁；
 - 共享锁(Shared Lock,S):允许事务读取一行，多个事务可以同时持有同一行的共享锁；
 - 排他锁(Exclusive Lock, X): 允许事务删除或更新一行，只有一个事务可以获取某一行的排他锁。

3. 间隙锁是什么？
间隙锁是InnoDB存储引擎在可重复读隔离级别下使用的一种锁机制。主要用来解决幻读问题，幻读就是指在一个范围内执行相同的两次查询时，可能会发现由于有新插入的行导致两次查询结果集不同。
- 间隙锁的作用就是它不会锁定特定的记录，而是锁定两个记录之间的间隙，防止其他事务在这个间隙内插入新记录；
- 可以防止幻读，保证了事务的隔离性。

---
### 算法topK问题

小顶堆
```java
PriorityQueue minHeap = new LinkedList<>();
```

---
### 消息队列有处理过发生延迟的情况吗？
会有，一般是网络问题或者是流量高峰的时候会出现。

- 首先我们会配置消息堆积量的告警，出现不同程度的堆积情况会有相应级别的告警；
- 消息队列客户端消费消息的话一般通过长轮训批量拉取消息，然后提交给消费线程。
- 如果出现消息堆积通常是客户端的消费能力跟不上，消息消费耗时比较长，或者是消费并发度不够。
- 首先优先解决消费耗时的问题，把消费耗时控制在合理的范围，比如如果有外部的IO操作，读写数据库、读写缓存、或者下游RPC调用或HTTP调用，都可能导致消费耗时增加，可以尝试本地缓存一些需要的数据。
- 可以扩大Topic分区数，扩大单个节点的并发线程数。

> 反正就是从消费耗时和并发度的角度优化吧。


**如何处理:**
- 查看是客户端还是服务端发生的堆积，查看客户端的堆栈信息，一般是网络问题、或者外部数据库读写问题。
- 如果堆积的消息可以跳过不消费的话，可以重置消费位点跳过这些堆积的消息从最新位点开始消费。
