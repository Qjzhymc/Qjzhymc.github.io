---
title: 完美世界面试题
author: Yu Mengchi
categories:
  - Interview
  - 面试知识点
tags:
  - Interview
---
  
### consumer怎么消费partition的？
Consumer是通过pull()方法拉去partition的消息的。指定topic和partition，broker返回一批数据。
consumer处理完消息后，调用commit提交消息offset值。消费者也可以指定offset值。

### scala和java对比？

scala也是一种机遇java虚拟机的编程语言，更灵活、简洁、多样化和可靠性强的特点。有以下优点：
- 函数式编程：scala提供了强大的函数式编程能力，可以更方便地处理并发和异步编程；
- 简洁性：scala可以用更少的代码完成同样的任务，可以提高代码的可读性和可维护性；
- 静态类型系统：scala的静态类型系统可以提高代码的可靠性和健壮性，能够在编译时捕获更多的错误。

为什么scala更灵活呢？
因为scala支持函数式编程和面向对象编程两种范式的混合使用。
1. 比如可以使用scala中的高阶函数对列表进行**函数式编程**，过滤filter、聚合reduce操作等。如：list.map(x=> x*x),list.filter(x => x % 2 == 0)
2. 可以使用scala中的**样例类**来定义数据类，使代码更简洁，比如：  

```scala
case class Person(name: String, age: Int) 

val person = Person("Alice", 25)

//通过copy生成新的实例
val updatedPerson = person.copy(age = 26)
```
3. 可以使用scala中的**隐式转换**来扩展类的功能：  

```scala
//为Int类型添加isEven方法
implicit class IntExtensions(val i: Int) {
  def isEven: Boolean = i % 2 == 0
}

val number = 4

//调用IntExtentions中的isEven方法
val isNumberEven = number.isEven
```

> 使用scala中的隐式类型转换可以方便地扩展类的功能，可以在编译期自动地将一个类型转换成另一个类型，而无需显式地调用转换函数，
> 比如要比较一个Int类型的变量和一个String类型的变量时，这两个类型不一致，没法比较。这时可以定义一个隐式转换函数，将Int类型隐式转换为String类型，使得它们可以被比较。

```scala
implicit class IntOps(val i: Int) {
  def addOne: Int = i + 1
  def isEqualTo(s: String): Boolean = i.toString == s  //为Int类型添加一个隐式类型转换函数，使得可以比较Int和String类型。
}

val number: Int = 42
val result = number.addOne
val isEqual = number.isEqualTo("42")
```

### play和springboot对比？play中有ioc、aop这种吗？
Play框架和Spring框架的区别：
1. 架构模式：Play框架采用了一种名为"reactive model"的架构模式，这种模式支持异步和非阻塞式的IO操作，可以更高效地处理大量请求。
Spring框架则是基于传统的"layered architecture"架构模式，支持阻塞式IO操作。
2. 编程语言：Play框架是基于Scala编写的，而Spring框架是基于java编写的。
3. Web框架：Play框架提供了一个全栈式的web框架，包括路由、模板引擎、表单处理、JSON处理等功能。
Spring框架则是一个由多个模块组成的框架，其中包括了Spring MVC和Spring Boot等与Web相关的模块。
4. 依赖注入：Spring框架是以依赖注入为基础的框架，内置了一个IOC容器。Play框架也支持依赖注入，但它是使用一个叫Guice的第三方库来实现的。

在Play框架中，虽然没有像Spring框架那样的IOC容器和AOP支持，但是它也可以通过Guic库进行依赖注入。Play框架也有类似于AOP的功能，
称为Action Composition，可以用来处理模块化的路由和请求处理。

### 在Play中，怎么进行依赖注入？

在Play中可以通过Guice库实现依赖注入：
1. 定义bean类
2. 创建Guice module
3. 使用bind()方法将bean绑定到Guice module上
4. 使用@Inject注解注入bean

```scala
//首先定义一个bean
class MyBean{
  def doSomething(): String = "hello world"
}

//然后创建一个Module，用bind()方法绑定bean到module上
class MyModule extends AbstractModule with ScalaModule {
  override def configure(): Unit = {
    bind[MyBean].asEagerSingleton() //bind()方法用于将接口或类绑定到其实现上
  }
}

//最后，在Controller或Service类中，通过@Inject注解注入bean
class MyController @Inject()(myBean: MyBean, cc: ControllerComponents) extends AbstractController(cc) {
  def index(): Action[AnyContent] = Action {
    Ok(myBean.doSomething())
  }
}
```


### redis淘汰策略


### 闭包


### 索引下推


### 一致性哈希算法


### 代码风格？嵌套怎么解决？

### 用哪些设计模式

### 联合索引是怎么查找的？


### redis 模型？

### redis SDS相比C快在哪？


### mysql有哪些锁？

### MVCC事务可见

### 乐观锁


### lru怎么实现的？


### var val 类型检测在哪里？


### 
