---
title: 蓝象科技面试题
author: Yu Mengchi
categories:
  - Interview
  - 面经
tags:
  - Interview
  - SpringBoot
---
  
### JMM
JMM是Java虚拟机规范中定义的一种内存模型，定义了Java中多线程并发访问共享内存时的行为。

JMM规定在并发访问共享内存时，每个线程都有自己的本地内存，线程之间的共享变量保存在主内存中，线程之间的通信通过主内存进行，而不是直接通过本地内存进行。

JMM规定了一些规则和约束，以确保多线程并发访问共享内存时的正确性。例如，JMM规定了volatile变量的读写具有原子性和可见性，禁止指令重排序。

1. 什么是JMM？为什么需要JMM？
确保多线程并发访问共享内存的正确性。

2. JMM中的主内存和工作内存分别是什么？它们之间的关系是什么？
主内存是存放所有共享变量的地方，工作内存是每个线程自己存放共享变量副本的地方。

主内存和工作内存的关系是通过内存屏障来实现的，内存屏障是一种同步机制，当一个线程执行到内存屏障的时候，会将本地内存修改的值同步到主内存中，并从主内存中读取最新的值到本地内存。

3. JMM中的可见性、原子性和有序性是什么？它们分别如何实现？
是多线程并发访问共享内存时需要保证的三个特性。
 - 可见性是指一个线程对共享变量的修改能立即被其他线程看到。在JMM中，可见性是通过内存屏障和缓存一致性协议来实现的。当一个线程修改共享变量的值后，会写回到主内存中，通过内存屏障强制刷新本地内存，以便其他线程能够看到它的修改。
 - 原子性是指一个操作不能出现中间状态，要么全部执行成功，要么全部执行失败。synchronized关键字和volatile关键字能够保证对共享变量的操作具有原子性，而原子类提供了一系列的原子操作，可以保证对共享变量的操作具有原子性。
 - 有序性是指程序执行的顺序要与代码中的顺序一致。JMM是通过内存屏障来实现的，内存屏障可以禁止指令重排序，保证程序的执行顺序与代码的顺序一致。

4. volatile关键字的作用是什么？它如何保证可见性和有序性？
volatile修饰的变量可以在多线程并发访问时保证可见性和有序性，但不能保证原子性，因为多个线程可能同时读取到volatile修饰的值，并且同时修改，就会出现竞态条件，导致数据不一致。
 - 可见性：当一个线程修改了共享变量的值，会立即写会到主内存，其他线程可以看到最新的值。
 - 有序性：禁止指令重排序，保证程序执行顺序与代码顺序一致。

5. synchronized关键字的作用是什么？它如何保证原子性和可见性？
能够保证被修饰的代码块或方法在同一时刻只能被同一个线程执行，保证了线程安全。可以保证原子性和可见性。
 - 原子性：一个线程在执行synchronized代码块或方法时，其他线程不能同时访问，保证了对共享变量的操作具有原子性。
 - 可见性：当一个线程获取对象的锁时，会清空本地内存中这个对象的值，并从主内存中重新读取该对象的值，从而保证了可见性 

6. JMM中的Happens-Before规则是什么？它是如何保证多线程程序的正确性的？
规定了多线程程序中操作之间的顺序关系，从而保证多线程程序的正确性。
 - 解锁先于加锁
 - 对volatile变量的写先于对该变量的读

7. 什么是指令重排序？JMM如何禁止指令重排序？

8. 什么是线程安全？如何保证线程安全？

9. 什么是ABA问题？如何解决ABA问题？

10. 什么是死锁？如何避免死锁？

---
### JVM内存模型

---
### HashMap结构，
内部是一个Entry类型的数组，数组中每个位置当成一个桶，每个Entry类型内部有键值对还有hash、next指针这些值，Entry下面也连接着链表，一个桶存放一个链表。

HashMap使用拉链法解决冲突，哈希值取模运算相同的Entry放在同一个链表上。

---
### ConcurrentHashMap结构？get时会加锁吗？
在jdk1.8之前，通过segment分段锁实现并发访问，segment控制多个HashEntry，默认有16个segment分段锁，segment是继承自ReentrantLock实现的，

在jdk1.8之后，使用CAS操作支持更高的并发度，CAS失败的时候会使用synchronized内置锁。

---
### String、StringBuilder、StringBuffer区别？
1. String是不可变的，对象创建后值就不能修改；所以String是天然的线程安全的字符串类，不会出现线程同步的问题；
2. StringBuilder是可变的，不是线程安全的；
3. StringBuffer也是可变的，但是StringBuffer是线程安全的，所有的公共方法都是同步的；

---
### 另一种没法解决的循环依赖是什么情况？

通过构造器注入导致的循环依赖是Spring没法解决的，因为构造器注入在创建bean实例的时候就必须提供所有依赖，所以在循环依赖的情况下，没法获得另一个还没有创建完成的bean来完成自己的初始化。

---
### 索引结构B+树结构？
1. 所有数据指针存放在叶子节点上；非叶子节点存放关键字和子节点指针，叶子节点存放关键字还有指向实际数据记录的指针。
2. 叶子节点之间通过链表形式相互连接，所以方便进行范围查询；
3. B+树是平衡树，所有叶子节点在同一层；
4. 树的高度较低，每个节点都有多个子节点；

---
### Synchronized和Lock区别？
1. 锁的获取和释放方式不同，lock需要显示获取和释放
2. synchronized是可重入锁，一个线程可以多次获取同一个锁，
3. synchronized在获取锁失败的时候会一直等待，直到获取锁。而lock可以设置等待时间，也可以在等待过程中中断线程
4. synchronized是非公平锁，不保证等待时间最长的线程最先获取锁，而lock可以通过构造函数指定锁的公平性

---
### 三色标记？

三色标记会把对象标记成三种颜色：
1. 白色：初始状态下，所有对象都是白色，表示没有被垃圾收集器访问过，如果最终标记完成后还是白色，说明这些对象是不可达的，可以被回收；
2. 灰色：灰色的对象表示已经被垃圾收集器发现并且至少存在一个对该对象的引用，但是该对象引用的其他对象还没有被完全扫描完毕；
3. 黑色：黑色对象表示不仅自己已经被标记为存活，而且它的所用引用也已经被处理过。

三色标记的过程：
1. 初始化阶段：所有对象都是白色的，从根集合中的对象开始标记成灰色，并且加入到待处理列表中；
2. 标记阶段：标记阶段从灰色对象开始，检查它所引用的所有对象；
- 如果被引用对象是白色，将它标记成灰色，加入到待处理列表中；
- 如果被引用对象已经是灰色或黑色，就不用处理；
3. 完成阶段：当没有灰色对象需要被处理时候，标记阶段结果；这个时候，如果还有白色对象剩余，就认为是不可达的垃圾，可以被回收；

但是因为应用线程和垃圾收集线程同时运行，所以会导致一些问题，比如"悬挂指针"问题。这个时候可以用一下策略解决：
1. 写屏障：每次修改对象图时候，都会触发写屏障机制。可以记录对象间引用关系的变化；
2. 增量更新(Incremental Update)或原始快照(SATB): SATB记录在GC开始前已经存在的对象状态；





















