---
title: 蓝象科技面试题
author: Yu Mengchi
categories:
  - Interview
  - 面试知识点
tags:
  - Interview
  - SpringBoot
---
  
### JMM
JMM是Java虚拟机规范中定义的一种内存模型，定义了Java中多线程并发访问共享内存时的行为。
JMM规定在并发访问共享内存时，每个线程都有自己的本地内存，线程之间的共享变量保存在主内存中，线程之间的通信通过主内存进行，而不是直接通过本地内存进行。

JMM规定了一些规则和约束，以确保多线程并发访问共享内存时的正确性。例如，JMM规定了volatile变量的读写具有原子性和可见性，禁止指令重排序。

1. 什么是JMM？为什么需要JMM？
确保多线程并发访问共享内存的正确性。
2. JMM中的主内存和工作内存分别是什么？它们之间的关系是什么？
主内存是存放所有共享变量的地方，工作内存是每个线程自己存放共享变量副本的地方。
主内存和工作内存的关系是通过内存屏障来实现的，内存屏障是一种同步机制，当一个线程执行到内存屏障的时候，会将本地内存修改的值同步到主内存中，并从主内存中读取最新的值到本地内存。
3. JMM中的可见性、原子性和有序性是什么？它们分别如何实现？
是多线程并发访问共享内存时需要保证的三个特性。
- 可见性是指一个线程对共享变量的修改能立即被其他线程看到。在JMM中，可见性是通过内存屏障和缓存一致性协议来实现的。当一个线程修改共享变量的值后，会写回到主内存中，通过内存屏障强制刷新本地内存，以便其他线程能够看到它的修改。
- 原子性是指一个操作不能出现中间状态，要么全部执行成功，要么全部执行失败。synchronized关键字和volatile关键字能够保证对共享变量的操作具有原子性，而原子类提供了一系列的原子操作，可以保证对共享变量的操作具有原子性。
- 有序性是指程序执行的顺序要与代码中的顺序一致。JMM是通过内存屏障来实现的，内存屏障可以禁止指令重排序，保证程序的执行顺序与代码的顺序一致。
4. volatile关键字的作用是什么？它如何保证可见性和有序性？
volatile修饰的变量可以在多线程并发访问时保证可见性和有序性，但不能保证原子性，因为多个线程可能同时读取到volatile修饰的值，并且同时修改，就会出现竞态条件，导致数据不一致。
- 可见性：当一个线程修改了共享变量的值，会立即写会到主内存，其他线程可以看到最新的值。
- 有序性：禁止指令重排序，保证程序执行顺序与代码顺序一致。

6. synchronized关键字的作用是什么？它如何保证原子性和可见性？
能够保证被修饰的代码块或方法在同一时刻只能被同一个线程执行，保证了线程安全。可以保证原子性和可见性。
- 原子性：一个线程在执行synchronized代码块或方法时，其他线程不能同时访问，保证了对共享变量的操作具有原子性。
- 可见性：当一个线程获取对象的锁时，会清空本地内存中这个对象的值，并从主内存中重新读取该对象的值，从而保证了可见性
7. JMM中的Happens-Before规则是什么？它是如何保证多线程程序的正确性的？
规定了多线程程序中操作之间的顺序关系，从而保证多线程程序的正确性。
- 解锁先于加锁
- 对volatile变量的写先于对该变量的读

8. 什么是指令重排序？JMM如何禁止指令重排序？
9. 什么是线程安全？如何保证线程安全？
10. 什么是ABA问题？如何解决ABA问题？
11. 什么是死锁？如何避免死锁？

### JVM内存模型

### HashMap结构，
内部是一个Entry类型的数组，数组中每个位置当成一个桶，每个Entry类型内部有键值对还有hash、next指针这些值，Entry下面也连接着链表，一个桶存放一个链表。
HashMap使用拉链法解决冲突，哈希值取模运算相同的Entry放在同一个链表上。
### ConcurrentHashMap结构？get时会加锁吗？
在jdk1.8之前，通过segment分段锁实现并发访问，segment控制多个HashEntry，默认有16个segment分段锁，segment是继承自ReentrantLock实现的，
在jdk1.8之后，使用CAS操作支持更高的并发度，CAS失败的时候会使用synchronized内置锁。

### String、StringBuilder、StringBuffer区别？


### 另一种没法解决的循环依赖是什么情况？


### 索引结构B+树结构？


### Synchronized和Lock区别？
1. 锁的获取和释放方式不同，lock需要显示获取和释放
2. synchronized是可重入锁，一个线程可以多次获取同一个锁，
3. synchronized在获取锁失败的时候会一直等待，直到获取锁。而lock可以设置等待时间，也可以在等待过程中中断线程
4. synchronized是非公平锁，不保证等待时间最长的线程最先获取锁，而lock可以通过构造函数指定锁的公平性
5. 

### 三色标记？

