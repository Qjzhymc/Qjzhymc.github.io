---
title: 微众面试题
author: Yu Mengchi
categories:
  - Interview
  - 面经
tags:
  - Interview
---
  
### tcp怎么建立连接
tcp是面向连接的麻，建立连接会有三次握手的过程，
首先客户端发送SYN标志的包，请求建立连接；
服务端收到后发送SYN+ACK包，进行连接；
客户端再回复一个ACK包，确认建立连接；

为什么要三次握手？要确保客户端和服务端都能正常接收和发送数据包

---
### spark运行机制？怎么读取文件？
spark

---
### jvm机制
jvm内存模型主要是划分成：程序计数器、java虚拟机栈、本地方法栈、堆和方法区。
其中程序计数器、java虚拟机栈、本地方法栈是线程私有内存区域，堆和方法区是线程共享的区域。
1. 程序计数器主要作为字节码文件的行号指示器，指示下一条需要运行的字节码指令；
2. java虚拟机栈主要是保存方法运行时的信息，内部有栈帧组成，每个栈帧包含局部变量表、操作数栈、动态链接、方法出口等信息，表示一个java方法的执行过程。
3. 本地方法栈和虚拟机栈一样，描述的是运行本地方法时的内存模型；
4. 堆主要存放对象实例和数组，是垃圾回收的主要区域；
5. 方法区主要存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。

---
### new一个对象有什么过程？
会先查看对应的类有没有加载到内存中，如果没有的话，就会通过类的全限定名来加载这个类，加载并初始化之后，再创建这个对象。
加载类的过程会遵循双亲委派模型，类加载器收到类加载的请求后，会先委托给父类加载器加载，最终会传送到启动类加载器，只有当父类加载器无法完成加载请求的时候，
才会自己尝试加载。
加载的过程会经过：加载->验证->准备->解析->初始化->使用->销毁 的一个过程
1. 加载阶段会根据类的全限定名读取字节流，生成对应类型的class对象
2. 验证阶段会clas对象是否符号jvm的规范要求
3. 准备阶段会为静态变量分配内存，设置初始值
4. 解析阶段会将常量池中的符号引用转换为直接引用
5. 初始化会真正初始化静态变量和其他资源，开始执行类中代码
类加载完之后，创建真正的对象：

---
### synchronized运行原理
首先synchronized是java中的一个关键字，一般用来修饰实例方法或同步代码块，实现线程同步。保证多线程访问同步代码的时候只有一个线程能获取到资源。
synchronized的底层实现是基于对象在内存中的存储格式来实现的，
一个java对象主要是由对象头和对象监视器monitor组成：
1. 对象头里有header、实例数据、对齐填充数据。对象头里又有类型指针、标记字段mark word，
标记字段里会存放对象运行时的一些状态信息，比如哈希码、GC分代年龄、锁的状态标志等，
2. monitor就是对象监视器，线程会通过monitor enter和monitor exit指令来获取和释放锁对象。

无锁：没有对资源锁定，所有线程都能同时访问修改对象，但同时只能有一个修改成功。
偏向锁：只有一个线程进入同步代码，
轻量级锁：其他线程会通过自旋的方式获取锁，不会发生阻塞
重量级锁：原始的synchronized实现，其他线程会阻塞，只有当前线程释放锁，才会唤醒。

---
### 怎么处理难点的？什么情况会出现OOM？GC什么情况不会回收？


---
### 项目有什么难点？


---
### spark和flink运行场景


---
### 线程池任务队列有哪些？


---
### Spring为什么有两种不同的动态代理jdk动态代理和cglib动态代理
1. JDK动态代理要求目标对象至少实现一个接口，代理类会实现相同的接口，在运行时会将调用转发给实际的目标对象。
2. CGLIB是通过生成目标类的一个子类来实现代理，所以目标对象可以不实现任何接口。

> 使用时，最好实现接口，使用JDK动态代理，更符合java标准。

---
### 动态代理怎么创建？
1. 首先创建接口和实现类
2. 然后创建hInvocationHandler实现类，在invoke()方法中处理方法调用，可以再这里添加增强逻辑
3. 然后使用的时候，可以通过Proxy.newProxyInstance(classLoader, class<>[], handler)创建代理对象，通过代理对象调用方法。

---
### 什么样的情况没法用三级缓存解决循环依赖？
- 使用构造器注入的方式
- 使用原型作用域的bean

---
### setter方式注入有没有循环依赖
有，如果是原型作用域的bean，setter方式也解决不了，因为每次请求原型作用域的bean，都会创建一个新的实例。没有使用缓存，所以没法用缓存机制解决循环依赖。

---
### Spring如何处理循环依赖？

Spring提供了几种方式来解决循环依赖问题，主要取决于Bean的作用域和注入方式：

1. 单例作用域下的属性注入（Field Injection）与Setter注入：
 - 对于单例Bean，如果使用的是属性注入或者setter方法注入，Spring可以通过三级缓存机制来解决循环依赖问题。
 - 当创建一个Bean时，Spring首先会实例化这个Bean，并将其放入“半成品”缓存中（第一级缓存）。然后，在执行属性填充或setter方法调用时，如果发现需要注入的Bean尚未完全初始化但已经被实例化（存在于缓存中），Spring就会使用该Bean的当前状态（可能是部分初始化的）来打破循环依赖链。
2. 构造器注入：
 - 如果使用构造器注入，则情况会有所不同。由于构造器注入要求所有依赖必须在对象构造期间提供，因此更容易暴露循环依赖问题，因为在这种情况下，Spring无法通过上述缓存机制来解决循环依赖。
 - 在这种情况下，Spring会在构建其中一个Bean时抛出BeanCurrentlyInCreationException异常，表明存在循环依赖。
3. 非单例作用域下的循环依赖：
 - 对于prototype（原型）作用域的Bean，Spring不支持解决循环依赖问题。这是因为每次请求原型作用域的Bean时都会创建一个新的实例，这使得Spring无法利用其内部的缓存机制来解决循环依赖。
