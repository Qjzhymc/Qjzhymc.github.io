---
title: 小黑盒面试题
author: Yu Mengchi
categories:
  - Interview
  - 面经
tags:
  - Interview
---
  
### 怎么给进程发信号
用kill命令，可以指定信号的编号，比如-9就是杀死目标进程。还有很多编号，可以用kill -l查看所有编号

---
### kill内部是有什么过程
kill会给进程发送SIGTERM信号，要求它优雅地停止服务。如果服务无法正常停止，可以使用SIGKILL信号强制终止服务。

---
### git rebase -i 的参数有什么作用，和git merge 有什么区别？
1. git rebase 将当前分支的修改应用到目标分支上，并将目标分支的修改合并到当前分支。
2. git merge 将两个分支的修改合并成一个新的提交。可能产生冲突，需要手动解决。

> -i参数表示打开交互式的编辑器，可以修改提交信息、合并提交、删除提交等。

---
### Kafka partition数量和consumer数量有什么关系，消费者组是什么作用？

一个partition可以被多个消费者组消费，但是在一个消费组内只能有一个消费者消费。

**消费者组的作用：**
- 消费者组会协调消费者，确保每个消息仅由一个消费者消费。当新的消费者加入或现有消费者离开时，消费者组会重新分配分区
确保负载均衡。
- 使用消费者组可以让一个分区被不同的消费者组消费，能并行消费消息，每个消费者组处理
一部分消息，提高性能和吞吐量。

---
### 什么是最左匹配规则？
是指在使用联合索引时，查询条件中的列必须按照索引中定义的顺序从左到右匹配，至少要包含联合索引的第一个列。

---
### 联合索引为什么有最左匹配规则？
- 主要是由B+树工作的原理决定的，建一个联合索引实际上是创建了一个基于多个字段组合的B+树。这个树首先根据第一个字段排序，第一个字段值相同再根据第二个字段排序，所以在查找的时候，如果缺少了前面的字段，就无法确定后续字段的具体位置，所以就不能利用到联合索引定位了。

**设计联合索引的原则：**
1. 最左边的列通常是选择性更高的列，这个列的不同值的数量更多，这样可以在早期阶段过滤掉大量不符合条件的记录，提高查询效率。
2. 尽量使用索引覆盖，就是查询的所有字段都可以通过索引获得，数据库可以直接从索引中获取所需的信息，不需要访问表数据本身，查询速度更快。

---
### B+树索引结构的工作原理

---
### B+树定义？结构？特点？

B+树是一种平衡的多路搜索树，主要用在数据库和文件系统中作为索引结构，可以减少磁盘IO操作次数，提高查询效率。

特点：
1. 所有叶子节点在同一层：所有数据访问都需要相同数量的磁盘读取。
2. 每个节点可以有多个子节点：树的高度较低。
3. 所有叶子节点通过链表链接在一起：所以范围查询很高效，找到起始点后沿着链表遍历找到结束点。

---
### 主键索引和其他辅助索引在B+树上有什么不同？
1. 主键索引：不重复(唯一)、不为空的列；如果没有指定，InnoDB会自动生成一个隐藏列作为主键索引
 - 叶子节点存放的是索引键值和数据行的所有列数据
2. 辅助索引：可以重复(除非是唯一索引)；
 - 叶子节点是索引键值和对应的主键值，不是整行数据，根据这个主键值去主键索引查找完整数据行，这种两次查找的过程称为"回表".

---
### 表更新时，乐观锁怎么实现
1. 使用版本号
2. 使用时间戳

> 实现乐观锁时，在数据表中添加一个版本号字段或时间戳字段，每次更新数据时都会将版本号或时间戳加1，当
提交数据时，检查当前版本号或时间戳是否和提交前一致，如果一致则提交成功，否则回滚。

---
### 乐观锁和悲观锁
悲观锁实现：表锁、行锁
1. SELECT ... FOR UPDATE:排他锁
用上面语句执行查询时，会对查询结果的每一行加上排他锁，直到当前事务结束
```roomsql
START TRANSACTION;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;

COMMIT;
```
2. SELECT ... LOCK IN SHARE MODE:共享锁
会给查询到的行加共享锁，其他事务也可以加共享锁但是不能加排他锁，适用于只读场景。

3. LOCK TABLES accounts WRITE;表级锁

> 还可以不用sql语句加锁，可以在应用层加锁，在redis上设置一个锁，可以使用redis的分布式锁。

---
### 不同事务隔离级别
1. 读未提交：允许一个事务看到其他事务未提交的更改；
 - 会产生的问题：脏读、不可重复读、幻读；
 - 没有限制对数据的访问，很少使用
2. 读已提交：不允许读取未提交的数据，避免脏读；
 - 会产生的问题：不可重复读(多次读取数据不一致)、幻读(多次查询结果集不同)
 - 实现方式：行级锁(共享锁)
3. 可重复读：在一个事务内多次读取返回相同的结果，解决不可重复读的问题；
 - 会产生的问题：幻读(没法阻止其他事务插入新记录)(InnoDB通过间隙锁解决幻读)
 - 实现方式：间隙锁+MVCC
4. 序列化：事务必须串行化执行

> InnoDB默认的隔离级别是可重复读

---
### 事务特性？i是啥？
1. A原子性：一个事务中的所有操作要么全部成功执行，要么全部不执行。中途发生错误需要回滚到初始状态。
 - 实现方式：日志
2. C一致性：事务必须从一个一致的状态转移到另一个一致的状态。事务开始前和结束和，数据库都应该处于一个合法的状态。
 - 满足所有的约束条件、触发器以及存储过程等逻辑规则；
 - 什么叫一致的状态：
3. I隔离性：多个并发事务之间相互独立、互不影响。不同的隔离级别提供了不同程度的保护，防止脏读、不可重复读、幻读等问题。
 - 四种隔离级别：
4. D持久性：一旦事务被提交，对数据库所做的所有更改都应该是永久性的。
 - 实现方式：持久化写入确认机制

---
### 用redis实现分布式锁？
1. 设置一个键值对到redis上，键是锁的标识符，值是不同客户端的uuid；
2. 使用的时候先加锁，使用完执行Lua脚本删除键值对，解锁。

> SET key value NX PX milliseconds   NX:仅当键不存在的时候才设置，PX设置过期时间，防止死锁。

---
### 进程僵尸进程和xxx进程区别？
僵尸进程就是指，一个子进程已经执行完了任务，并调用了exit函数，但是它的父进程没有回收资源，导致子进程的资源描述符还在进程表中，只剩下空壳进程的状态。

处理僵尸进程的方法就是使用wait()或waitpid()方法，对子进程资源进行回收，并从进程表中删除。

---
### 更新缓存策略？

延迟双删：先删除缓存项，更新数据库项，等待一段时间后，再次删除缓存。防止删除缓存后但数据库更新前其他线程把旧数据再次加载到缓存。

