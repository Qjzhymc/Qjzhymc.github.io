---
title: Java线程安全
author: Yu Mengchi
categories:
  - Interview 
  - 面试知识点
  - Java基础
tags:
  - Interview
  - Java
---

---
### 实现线程安全的方法有哪些？
1. 互斥同步(阻塞同步)：
- synchronized关键字
- JUC包的ReentrantLock
2. 非阻塞同步
- volatile关键字
- 原子类(AtomicInteger)
3. 无同步方案
- 可重入代码
- 线程本地存储ThreadLocal：将数据限制在单个线程内

---
### 使用多线程应该注意的事项？
1. 访问共享变量的时候需要注意线程安全。
2. 使用锁机制的时候防止死锁。多线程加锁需要注意的点：
- 按固定顺序获取锁
- 限制加锁时间，通过tryLock()尝试获取锁
- 仅锁定必要的资源，最小化锁的粒度，缩小锁的范围；
- 优先使用原子类，并发集合；
- 异常处理，在finally里释放锁；
3. 使用线程池处理任务，设置合理的参数。

---
### java中的lock和synchronized的区别？
两个都可以用来实现线程同步，但是使用上有一些区别：
1. 首先synchronized是java语言的关键字，用于修饰同步方法或同步代码块；Lock是一个接口，ReentrantLock是它的实现类，需要调用lock()方法获取锁，调用unlock()方法释放锁；
2. Lock可以通过tryLock()方法尝试获取锁，如果锁不可用会立即返回，可以设置等待时间，还可以查询当前线程是否持有锁。
3. synchronized锁不支持公平锁，线程获取锁的顺序是随机的；Lock锁可以通过ReentrantLock的构造函数指定是否为公平锁。
4. Lock可以创建条件变量，然后通过条件变量的 await(),signal() 方法实现通知等待机制。
5. 最后就是性能上，synchronized有自旋锁、锁粗化、锁消除机制，性能上接近Lock。

> 使用总结的话，如果只需要简单的线程同步，而且对锁的功能要求不高的话，推荐使用synchronized，因为它更安全，更简单。
如果需要更灵活的锁操作，比如说想要tryLock、想要创建条件变量、或者创建公平锁的话，推荐使用Lock。

---
### synchronized运行原理
运行原理是通过**monitor-enter指令获取对象锁**，如果成功，获取对象锁，如果失败，会进入monitor监视器的等待队列进行等待。**释放锁的时候通过monitor-exit释放对象锁，同时唤醒等待队列里的等待线程**。
- synchronized修饰对象时：如果修饰的是对象，那么他是依赖于monitor对象来实现锁的机制的。当monitor被其他线程占用时就会处于锁定状态，线程执行monitor-enter指令时尝试获取monitor的所有权。线程退出monitor的时候，执行monitor-exit指令。
- synchronized修饰方法时：那么则是通过ACC_SYNCHRONIZED标识符来进行加锁的。

synchronized的底层实现是**基于对象在内存中的存储格式**来实现的，

一个java对象主要是由对象头、实例数据、对齐数据组成的，对象头里的mark word会有很多标记字段，标记字段里会存放对象运行时的一些状态信息，比如哈希码、GC分代年龄、锁的状态标志等。
1. 如果这个对象被当成锁来用的话，就会有指向Monitor的指针，Monitor是一个监视器类，里面有持有monitor的线程、有等待队列、还有计数器；
2. monitor就是对象监视器，线程会通过monitor enter和monitor exit指令来获取和释放锁对象。

---
### ReentrantLock原理？AQS是如何实现的？
AQS是juc里的一个抽象基类，可以在多线程环境下实现线程安全和并发控制。
AQS内部是一个存放等待线程的双向链表，有一些原子操作实现对状态的管理。AQS定义了一些方法比如acquire、release等，不同的同步器子类可以实现这些方法实现
不同的同步策略。

---
### volatile的实现原理
volatile是java中用来修饰变量的一个关键字，可以保证线程之间变量的可见性和有序性

1. 可见性就是说当一个线程修改了volatile变量的值的时候，这个变量的新值会立即写回到主内存，这样的话就可以确保不同线程对变量的读取操作都能获取到最新的值。
   实现可见性的原理就是**java内存模型中规定当一个线程要读取volatile变量的时候，会直接从主内存中获取最新的值，而不是从线程的本地内存中获取**，
   同样要修改volatile变量的时候，会立即将新值写回到主内存，这样的话就能保证其他线程看到最新的值。
2. 有序性就是说，在进行读取和修改volatile变量的时候，会按照在代码中的顺序执行，不会和其他指令发生重排序，保证了操作的有序性。
   实现的原理就是**volatile变量会使用内存屏障的机制来禁止指令重排序。在volatile变量的读写操作前后会插入相应的内存屏障，确保所有的读写操作都按照代码的顺序执行。**

但是volatile关键字没法保证原子性，也就是说当多个线程同时对volatile变量进行操作时，还是有可能出现竞争的情况。
如果需要保证原子性的话，可以考虑使用锁或者原子类来替代volatile。

---
### 原子类原理？ CAS操作
CAS操作是一种原子指令，用于解决并发环境下共享数据的原子更新问题。juc里的原子类会使用到CAS操作。
操作包含三个操作数：**内存位置（或者说变量）、预期值和新值**。
执行过程的话：
1. 首先会读取当前内存位置的值，保存下来作为预期值
2. 然后在写入的时候，会比较预期值和当前内存位置上的值是不是相等，如果相等，说明没有其他线程修改过，将新值写入到内存位置，更新完成；
3. 如果不相等，说明有其他线程修改过，本次cas操作失败，需要重试。

---
### ThreadLocal类是否线程安全？什么情况出现线程安全问题？如何解决？
ThreadLocal可以实现线程本地存储，把共享数据的可见范围限制在一个线程里面，这样的话不需要同步操作也能保证数据互不影响。
原理就是每个线程里面都有一个ThreadLocalMap对象，map里存放了所使用的ThreadLocal对应的value值，每次线程调用get或set方法的时候都会先获取
线程对应的ThreadLocalMap，然后对map里的键值对修改。

可能出现内存泄漏的问题，threadlocal是弱引用，value是强引用，threadlocal回收后可能value值还存在。
解决方法就是每次使用完ThreadLocal后执行remove操作。

---
### Synchronized锁升级
虚拟机会根据锁的竞争情况升级锁的状态，减少性能消耗。

锁的状态分别是：无锁->偏向锁->轻量级锁->重量级锁。升级过程是单向的，只能从低到高。

- 无锁：没有对资源锁定，所有线程都能同时访问修改对象，但同时只能有一个修改成功。
- 偏向锁：只有一个线程进入同步代码
- 轻量级锁：其他线程会通过自旋的方式获取锁，不会发生阻塞
- 重量级锁：原始的synchronized实现，其他线程会阻塞，只有当前线程释放锁，才会唤醒。

1. 当线程第一次获取锁的时候，进入偏向锁状态。会在对象头中记录该线程的ID，将锁标记位记为01；
2. 当其他线程尝试获取锁的时候，偏向锁会升级为轻量级锁。
- 线程进入同步块前，jvm在当前线程的栈帧中创建一个名为锁记录Lock Record的空间，用于存储对象头的mark word拷贝
- 通过CAS操作，尝试将对象头的mark word更新为指向锁记录Lock Record的指针；
  - 如果成功，线程获取到轻量级锁，锁标志位为00
  - 如果失败，说明有其他线程持有锁，当前线程进入自旋等待状态，也就是通过循环尝试获取锁
3. 当自旋次数超过阈值，轻量级锁升级为重量级锁，重量级锁会依赖操作系统的互斥量(Mutex),会导致线程挂起和唤醒，性能开销大
- 重量级锁依赖操作系统的Mutex Lock实现，线程获取锁失败时会被挂起进入内核态，锁释放时再唤醒线程。
- 锁标志位为10，mark word指向操作系统的互斥量

---
### synchronized保证可见性的原理？
可见性：当一个线程对共享变量修改后，其他线程能够看到修改后的数据。

主要依赖于**java内存模型(JMM)**和还有一些底层的支持；
1. 比如内存屏障，在进入同步代码块之前和退出同步代码块之后，jvm会插入内存屏障指令，**这些指令确保在这期间，对共享变量的操作都是在主内存中进行的，而不是线程本地的工作内存的副本**，这样其他线程能立即看到共享变量的修改。
2. happens-before规则，确定一个操作是否对另一个操作是可见的。对于synchronized，解锁操作happens-before后续对该监视器锁的加锁操作。这意味着如果一个线程A解锁了一个监视器锁，并且随后另一个线程B加锁了同一个监视器锁，则线程A在解锁前对共享变量的所有修改都对线程B可见。
3. 缓存一致性协议：处理器都会有缓存一致性协议，确保每个核心上的缓存与主存数据保持一致，当一个线程释放锁时，会刷新其缓存到主存；当另一个线程获取锁时，会强制让缓存失效，从主存重新加载数据。确保了所有线程看到的是最新的数据状态。

---
### synchronized锁静态方法和锁普通方法有什么区别？
1. 锁静态方法：锁的是类的Class对象。
2. 锁普通方法：锁定的是调用该方法的对象，即当前实例

---
### 两个线程同时对一个被volatile修饰的变量进行自增操作，结果如何，应如何保证结果正确？
volatile只能保证变量的可见性，没法保证原子性，所以结果可能小于预期值。

如果要保证原子性，只能用synchronized(加锁)，原子类(CAS无锁方案)，LongAddr等(分段累加)。

---
### CAS操作三大问题，以及怎么解决
1. ABA问题：使用CAS操作的时候，比如原子类的操作时，可能会出现ABA问题，就是在判断内存地址的值等于期望值的时候，有可能被其他线程修改过，但是CAS操作没法感知这种修改，可能导致逻辑出错。
- 解决方法：使用AtomicStampedReference带引用的原子类，会保存reference对象引用和stamp，这个stamp可以看做是版本号，每次更新引用的时候也会更新版本号，这样即使引用的值变回原来的值，但是版本号会不一样，所以可以解决ABA问题；
2. 长时间自旋问题：原子类设置值的底层实现有一个do while循环，如果while条件不满足的话，会无限循环。
- 解决方法：使用LongAdder类，它会有一个base和cell[]数组，线程会分散到不同的cell进行累加，减少冲突；
3. 一般的Atomic原子类只能保证一个共享变量的原子操作，如果需要对多个共享变量保证原子性，CAS做不到
- 解决方法：使用AtomicReference类，把多个变量放到一个对象里，进行CAS操作

---
### 实现一个死锁的程序

```java
public class deadLock {

    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();

    public static void main(String[] args) {

        Thread thread1 = new Thread(() -> {
           synchronized (lock1) {
               System.out.println("线程1：拥有锁1");
               try {
                   Thread.sleep(100);
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }

               System.out.println("线程1：等待锁2");
               synchronized (lock2) {
                   System.out.println("线程1：拥有锁1和锁2");
               }
           }
        });
        
        Thread thread2 = new Thread(() -> {
            synchronized (lock2) {
                System.out.println("线程2：拥有锁2");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("线程2：等待锁1");
                synchronized (lock1) {
                    System.out.println("线程2：拥有锁2和锁1");
                }
            }
        });

        thread1.start();
        thread2.start();
    }
}
```

死锁的四个必要条件：
1. 互斥条件：资源只能被一个线程占用
2. 占有并等待：线程占有资源同时等待其他资源
3. 不可剥夺：线程占用的资源不能被强制释放
4. 循环等待：存在线程在循环等待资源

为避免死锁，使用锁的时候可以采取以下措施：
1. 按顺序加锁
2. 使用超时机制，比如tryLock方法
3. 减小锁的粒度
4. 使用高级并发工具，比如ReentrantLock提供的tryLock或Lock接口


