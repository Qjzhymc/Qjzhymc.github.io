---
title: Java垃圾回收
author: Yu Mengchi
categories:
  - Interview 
  - 面试知识点
  - Java基础
tags:
  - Interview
  - Java
---

---
### 怎么判断对象可以被回收？
通过引用计数法或可达性分析算法来判断这个对象是否能被回收：
1. 引用计数法：会对每个对象记录其被引用的次数，当引用次数为0的时候，可以认为可以被回收
2. 可达性分析：会从根对象开始扫描，在依次扫描完能够到达的所有对象后，所有未被扫描到的对象就被视为垃圾对象进行回收。

---
### 可达性分析算法
将GC Roots对象作为起点，从这些起点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的对象都是垃圾对象。

---
### 堆内存回收的步骤
可达性分析判断存活对象， GC Roots：
- 虚拟机栈引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈引用的对象。
1. 垃圾标记：初始标记(暂停所有用户线程；仅标记GC roots直接引用的对象)，并发标记(与用户线程同时运行，从GC Roots开始标记所有可达对象)，重新标记(修正并发标记因用户线程活动导致的标记变动)
2. 垃圾回收算法：复制-整理算法

---
### gc调优目标
1. 减少GC的停顿时间
- 选择低延迟的GC收集器，比如G1、ZGC；
- 调整堆大小，减少GC次数，尤其是Full GC(老年代大一点)；
- 减少不必要的对象创建；

---
### jvm有哪些垃圾回收算法？CMS和G1使用什么场景
常见的垃圾回收算法有：
1. 标记-清除：从根出发，标记所有可以到达的对象，不可到达的对象会回收。该算法的缺点是会产生内存碎片，影响内存利用效率。
2. 标记-整理：首先进行标记，然后将所有存活的对象移动到内存的一端，然后清除另一端的所有对象。这个算法的优点是不会产生内存碎片，但是需要移动对象，影响效率。
3. 复制：把堆分成同样的大小的两块，每次只使用其中一块，当这一块用完了，就将活跃对象复制到另一块，同时清空原来的块。通常使用在新生代。该算法的缺点是每次只能使用一半的内存空间，适用于存活对象比较少的情况。
4. 分代收集：将堆内存分成几个代空间，有新生代、老年代，不同代的垃圾回收使用不同的算法，比如新生代会使用复制算法，老年代会使用标记-清除或标记-整理算法。新生代回收时，会将活着的对象复制到另一个空间，原来的空间清理掉，这个过程叫Minor GC；当对象在新生代回收过很多次还存在的时候，会被晋升到老年代，当老年代满了的时候会发生Full GC

为什么用分代收集：
分代收集会根据对象的生命周期长短，将内存划分成不同的代，对不同代采用不同的回收频率和回收算法，提高回收效率，降低性能开销。
1. 大部分对象存活时间短
2. 少数对象存活时间长
- 减少内存碎片：新生代通过复制算法整理内存，无碎片；老年代通过标记-整理算法压缩内存；
- 减少STW时间

常见的垃圾回收器有：
1. Serial收集器：特点是单线程，使用标记-复制算法；
2. ParNew收集器：是多线程版本的Serial收集器，适用于新生代；
3. Parallel Scavenge收集器：也是多线程，使用高吞吐量的应用；
4. Serial Old收集器：单线程，适用于老年代，使用标记-整理算法；
5. Parallel Old收集器：多线程，老年代，也是使用标记-整理算法；
6. CMS收集器：并发，目标是最小化停顿时间，使用标记-清除算法，适合对响应时间要求比较高的应用，比如web服务器。
7. G1收集器：特点是分区收集，把堆划分成多个区域，优先回收垃圾最多的区域。

使用场景：
1. CMS适用于对响应时间要求比较高的应用，适合老年代的垃圾回收；
2. G1适用于大内存、多处理器的机器，堆大小比较大而且需要低GC延迟的应用，优点是可以并行收集、分区收集、避免内存碎片。

总结的话CMS收集器适合对响应时间要求高的应用，但是可能会遇到内存碎片和停顿时间过长的问题。G1收集器更适合大内存、多处理器的服务器应用，尤其是需要低GC延迟和高吞吐量的场景。

G1的优点：
1. 分区收集，优先回收垃圾最多的区域，而不是整个堆，这样的话可以更灵活控制回收时间；
2. 可预测的停顿时间，G1提供一个参数叫-XX：MaxGCPauseMillis，每次垃圾回收时尽量控制停顿时间不超过这个值，G1会根据目标停顿时间和内存使用的情况，动态调整每次回收的区域数量，从而实现更稳定的停顿时间；
3. 可以避免内存碎片：G1会在垃圾回收时将存活对象复制到其他区域，较少Full GC的频率。

G1回收过程：
1. 初始标记：暂停所有用户线程，标记直接可达的根对象，比如全局变量、栈帧中的引用。这个过程会很快；
2. 并发标记：用户线程继续运行，垃圾回收线程开始并发执行，从初始标记阶段标记的根对象开始，遍历整个堆，进行**可达性分析**，标记所有可达的对象。这个时候因为用户线程还在并发运行，所以可能会有新的对象被创建或者对象引用关系发生了变化，G1会通过Remembered Set（记忆集）来记录这些变化；
3. 最终标记：会根据并发标记阶段记录的对象修改，最终标记哪些对象是存活，哪些对象是垃圾

Young Collection-> Young Collection + Concurrent Mark -> Mixed Collection -> Full GC

---
### 堆内存分配的步骤？分配规则？
1. 新创建的对象会分配到Eden区，Eden区内存不够的时候会触发MinorGC，对新生代区进行一次垃圾回收；
2. MinorGC会清除Eden区的没有被GC roots标记的对象，存活的对象会被复制到Survivor From区，然后标记这些对象的分代年龄为1；
3. Eden内存不够又会触发一次MinorGC，一样清理垃圾，From区也会被清理，没有被清理的对象会被复制到To区，清理Eden区和From区，然后From和To区互换，原来的To区成为下一次GC时的From区；
4. 一直这样重复，如果对象的分代年龄达到了15次，这个对象就会被复制到老年代；(对象头mark word里分代年龄字段是4bit，最大是1111，所以是15)
5. 老年代内存不够时会触发Full GC清理整个堆空间，包括新生代和老年代。这个时候会停止所有用户线程；
6. 如果Full GC后还没有更多的空间存放新对象就会发生OOM。

分配规则？
- 优先分配到新生代的eden区
- 大对象保存到老年代(比如很长的字符串或者大的数组byte[])
- 长期存活对象保存到老年代,对象年龄为15

空间分配担保

TLAB

> 新生代：老年代= 1： 2；Eden区：Survivor区 = 8：2； From区 ： To区 = 1：1；

---
### 什么时候会触发full GC
1. 手动调用System.gc()方法，但也不保证立即触发；
2. 老年代剩余空间不足，无法通过空间分配担保时；
3. 元空间不足，元空间存放类元数据、字符串常量，如果加载的类太多了，比如通过动态代理加载了太多的类，导致元空间不足，超过MaxMetaspaceSize；
4. 堆内存空间不足；

---
### JVM的永久代会发生内存回收吗

---
### 哪些内存区域会触发OOM

---
### 元空间受jvm内存影响吗？
- 堆外内存：元空间不在jvm堆内存里，在本地内存中，不会影响到堆内存的使用。
- 但是还是可以通过设置jvm参数设置元空间大小的，-XX:MaxMetaSpaceSize。
- 元空间是在java 8中引入的，用于替换永久代，主要用来存储类的元数据，比如类名、接口名列表、常量池等。
- 如果没有类加载器引用某个类的时候，这个类的元数据也是可以被垃圾回收的。

> 方法区是规范。永久代和元空间都是实现。
> 在jdk1.8之前，方法区的实现是用永久代；在jdk1.8之后，方法区的实现是用元空间，并且不再使用虚拟机内存而是本地内存。

---
### 三色标记？

三色标记会把对象标记成三种颜色：
1. 白色：初始状态下，所有对象都是白色，表示没有被垃圾收集器访问过，如果最终标记完成后还是白色，说明这些对象是不可达的，可以被回收；
2. 灰色：灰色的对象表示已经被垃圾收集器发现并且至少存在一个对该对象的引用，但是该对象引用的其他对象还没有被完全扫描完毕；
3. 黑色：黑色对象表示不仅自己已经被标记为存活，而且它的所有引用也已经被处理过。

三色标记的过程：
1. 初始化阶段：所有对象都是白色的，从根集合中的对象开始标记成灰色，并且加入到待处理列表中；
2. 标记阶段：标记阶段从灰色对象开始，检查它所引用的所有对象；
- 如果被引用对象是白色，将它标记成灰色，加入到待处理列表中；
- 如果被引用对象已经是灰色或黑色，就不用处理；
3. 完成阶段：当没有灰色对象需要被处理时候，标记阶段结束；这个时候，如果还有白色对象剩余，就认为是不可达的垃圾，可以被回收；

但是因为应用线程和垃圾收集线程同时运行，所以会导致一些问题，比如"悬挂指针"问题。这个时候可以用以下策略解决：
1. 写屏障：每次修改对象图时候，都会触发写屏障机制。可以记录对象间引用关系的变化；
2. 增量更新(Incremental Update)或原始快照(SATB): SATB记录在GC开始前已经存在的对象状态；
