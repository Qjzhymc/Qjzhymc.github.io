---
title: 计算机网络面试题
author: Yu Mengchi
date: '2023-03-09 19:02 +8'
categories:
  - Interview 
  - 面试知识点
  - 计算机基础
tags:
  - Interview
  - Network
---

# 计算机网络

---

### 介绍OSI和TCP/IP网络分层模型，以及每一层主要有哪些协议，以及每一层的主要功能是什么？

1. OSI七层模型包括应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。
- 应用层的功能是为计算机用户提供服务；
- 表示层提供数据处理功能（比如编解码、加密解密这些操作）；
- 会话层负责管理应用程序之间的会话；
- 传输层为两台主机进程之间的通信提供通用的数据传输服务；
- 网络层主要是路由和寻址；
- 数据链路层为帧编码以及提供误差纠正控制；
- 物理层负责透明地传送比特流数据。
2. TCP/IP模型主要有应用层、传输层、网络层和网络接口层。
- 应用层主要提供两个终端设备上的应用程序之间信息交换的服务，在应用层交互的数据单元是**报文**，应用层协议有HTTP、FTP、SMTP、POP3协议；
- 传输层主要负责为两台终端设备进程之间的通信提供**通用的数据传输服务**，传输层协议主要有TCP和UDP协议；
- 网络层主要功能就是**路由和寻址**，负责为分组交换网上的不同主机提供通信服务，还有为传输层传下来的分组选择合适的路由，网络层协议主要有IP/IPv6协议、ARP、ICMP；
- 网络接口层可以分为数据链路层和物理层，链路层的作用是**将网络层交下来的IP数据报组装成帧**，在两个相邻节点间的链路上传送帧，物理层的作用是**实现相邻计算机节点间比特流的透明传输**，尽可能屏蔽掉具体传输介质和物理设备的差异。

---

### 介绍每一层包含的协议？核心技术？

1. 应用层协议有：
- HTTP协议（超文本传输协议）
- FTP协议（文件传输协议）
- Telnet协议（远程登陆协议）
- 电子邮件协议（SMTP、POP3、IMAP）
- DNS系统原理（域名系统）
- DHCP协议（动态主机配置）
- SMTP

2. 传输层协议有：
- TCP协议（核心技术有报文段结构、可靠数据传输、流量控制、拥塞控制）
- UDP协议（核心技术有报文段结构、RDT（可靠数据传输协议））

3. 网络层协议有：
- IP协议
- ARP协议（地址解析协议，用于解析IP地址和MAC地址之间的映射）
- ICMP协议（控制报文协议，用于发送控制消息）
- NAT协议（网络地址转换协议）
- RIP协议、OSPF协议、BGP协议（路由选择协议）

4. 网络接口层主要技术有：
- 差错检测技术
- 多路访问协议（信道复用技术）
- CSMA/CD协议
- MAC协议
- 以太网协议
- Wi-Fi
- PPP(点对点协议)

---
### 为什么要网络分层？

- 分层可以让每一层专注于做一类事情，各层之间相互独立，不需要关心其他层是怎么实现的。
- 分层可以提高系统的灵活性，每一层可以选择最合适的技术实现就可以，只需要提供的功能符合规则就行。
- 分层可以把复杂的网络问题分解为一个个小问题，使整个网络系统容易实现，容易标准化。

---
### 介绍TCP和UDP？有什么区别？

1. TCP是指传输控制协议，提供面向连接的，可靠的数据传输服务。
2. UDP是用户数据协议，提供无连接的，尽最大努力的数据传输服务，也就是不保证数据传输的可靠性。之间的区别主要有：

- TCP提供**面向连接**的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接，UDP在传送数据之前不需要先建立连接。
- TCP提供**可靠**的传输服务，在数据传递的时候，**有确认机制、有重传机制、有拥塞控制机制**，数据可以保证不丢失、不重复而且是有顺序到达的。而UDP在传送数据时不会给出任务确认机制，也不保证数据不丢失、不保证是顺序到达的。
- TCP传输是**有状态**的，TCP会记录消息发送的状态，比如消息是否发送了、是否被接收，而UDP是无状态服务。
- 传输效率TCP因为有**连接机制、确认机制、重传机制**，所以会比UDP效率低。
- 传输形式上TCP是面向**字节流**的，UDP是面向**报文**的。
- TCP报文首部开销一般是20-60个字节，比UDP首部开销要大，UDP首部是8字节。
- TCP只支持点对点通信，而UDP支持一对多、多对一、多对多的广播或多播服务。

---
### TCP，UDP区别
1. TCP是传输控制协议，是面向连接的，能够保证数据可靠，有重试机制、确认机制、拥塞控制机制。可以保证数据不丢失、不重复、有序到达。
2. UDP是用户数据报协议，是无连接的，不保证数据可靠，适用于在线视频，语音等应用。

---
### 什么时候选择TCP，什么时候选择UDP？应用场景的区别？

- TCP一般用于对传输准确性要求比较高的场景，比如文件传输、发送和接收邮件、远程登陆这些。
- UDP一般用于对传输数据准确性要求不高的场景，比如即时通信，语音、视频、直播这些。

---
### tcp有哪些机制保证数据准确
1. tcp传输的数据有序列号，接收方收到数据后会发送ACK(确认应答),告诉发送方自己已接收数据的最后序列号；
2. 超时重传机制：发送方如果一段时间内没有收到ACK，会重传；
3. 流量控制：接收方会通知发送方当前缓冲区大小，防止发送方发送过多的数据；
4. 拥塞控制：TCP会根据网络状态动态调整发送速率，减少网络拥塞情况。拥塞算法有慢启动、拥塞避免、快速重传、快恢复；
5. 校验和机制：TCP头有一个校验和字段，检测数据包是否一致。

---
### HTTP是基于TCP还是UDP？

在HTTP3.0版本之前(HTTP/1.1和HTTP/2.0)是基于TCP协议的，在3.0的版本中改为使用基于UDP的QUIC协议。
主要解决的问题是之前版本中存在的HOL Blocking问题（队头阻塞问题），之前版本传输层使用TCP协议，少量的丢包可能导致整个TCP连接上所有流被阻塞。

> **队头阻塞问题**：在TCP里数据被分成多个Segment段传输，每个段按照发送顺序会分配一个序列号，接收端会
> 根据这些序列号重新组装原始的数据流。如果某个段丢失或者延迟，即使后续的段已经到达接收端，也没法立即传给应用层，
> 因为TCP需要保证按序交付，所以后面的所有数据都要等丢失的段重传成功后才能继续处理，就会发生队头阻塞问题。

---
### HTTP2.0比HTTP1.0有哪些改进？

1. 头部压缩：HTTP2使用HPACK算法对HTTP头部进行压缩，减少了传输的数据量；
2. 多路复用：之前每个请求都需要建立一个新的TCP连接，会导致"线头阻塞"问题(也就是一个请求的延迟会影响后续请求的处理)，HTTP2允许在一个TCP连接上同时发送多个请求和响应。
3. 服务器主动推送：服务器可以主动向客户端发送资源，比如当用户请求一个HTML页面的时候，服务器可以预测到该页面还需要哪些文件，可以提前推送给客户端。


---
### 使用TCP协议有哪些？使用UDP协议有哪些？

1. 运行于TCP协议之上的协议有：

- HTTP协议、HTTPS协议
- FTP协议
- SMTP协议
- POP3/IMAP协议
- Telnet协议
- SSH协议

2. 运行于UDP协议之上的协议有：

- DNS：域名系统，将域名转换为IP地址；
- DHCP协议：动态主机配置协议，动态配置IP地址

---
### TCP三次握手和四次挥手

- 首先客户端发送带有SYN标志的数据包给服务端，并且客户端进入SYN_SEND状态，等待服务器的确认；
- 然后服务端发送带有SYN和ACK标志的数据包给客户端，服务端进入SYN_RECV状态；
- 最后客户端发送带有ACK标志的数据包给服务端，客户端和服务端就都进入ESTABLISHED状态，完成三次握手；

1. 为什么要三次握手？

因为要保证从客户端视角和服务端视角确认对方和自己发送和接收都正常，才能保证建立了可靠的通信信道。

|      |客户端视角|服务端视角|  
|:----:|:------:|:-------:|  
|第一次握手|不知道自己有没有发送成功，也不知道的对方有没有接收到|收到SYN包，确认**对方发送正常**，**自己能正常接收**|  
|第二次握手|收到服务端的正确响应，说明自己最开始发送的包被对方成功接收，**自己发送正常**，**自己接收正常**，**对方发送正常**，**对方接收正常**|和上面一样|
|第三次握手|和上面一样，客户端确认自己和对方的发送和接收都正常|收到客户端的第二个SYN包，表示**自己发送正常**，**对方接收正常**|

2. 第2次握手传回了ACK，为什么还要传回SYN？

服务端传回客户端发送的ACK是为了告诉客户端：我能正常接收到你的数据。表示客户端的发送是正常的。但是服务端到客户端的发送还不能确定能通，所以回传SYN是为了建立从服务端到客户端的通信。

3. 为什么要四次挥手？

因为TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

4. 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手？

因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。

5. 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？

客户端没有收到ACK确认，会重新发送FIN请求。

6. 为什么第四次挥手客户端需要等待2*MSL（报文段最长寿命）时间后才进入CLOSED状态？

第四次挥手时，客户端发送给服务器的ACK有可能丢失，如果服务端因为某些原因而没有收到ACK的话，服务端就会重发FIN，如果客户端在2*MSL时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止服务端没有收到ACK而不断重发FIN。

> MSL(Maximum Segment Lifetime):一个报文段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果2MSL后，客户端都没有收到FIN，那么客户端推断ACK已经被成功接收，则结束TCP连接。

---
### tcp怎么建立连接
tcp是面向连接的，建立连接会有三次握手的过程，
首先客户端发送SYN标志的包，请求建立连接；
服务端收到后发送SYN+ACK包，进行连接；
客户端再回复一个ACK包，确认建立连接；

为什么要三次握手？要确保客户端和服务端都能正常接收和发送数据包

---
### 回顾一下四次挥手过程？

关闭连接的时候，会需要进行四次挥手
1. 主动关闭的一方会发送一个FIN包，表示服务端可以关闭连接了；
2. 服务端收到了发送一个ACK响应，表示自己已经接收到关闭请求，但是程序还需要做一些后续操作，此时，服务端会进入CLOSE_WAIT状态；
3. 服务端处理完事情之后，在给客户端发送FIN包；
4. 客户端收到后，发送ACK包给服务端，这个时候客户端会处于time_wait状态，如果2MSL时间后都没有收到服务端的FIN包就会进入closed状态。

---
### TCP server close_wait值很高，应该怎么解决？
如果一个服务有很多连接处于close_wait状态，说明程序中没有合理的关闭socket连接。

---
### time_wait状态的连接太多怎么解决？
先通过命令查看连接状态
netstat -a | grep TIME_WAIT | wc -l
一般是通过sysctl.conf文件，配置网络，复用连接或回收连接，参数一般有这几个：
1. net.ipv4.tcp_tw_reuse = 1; 表示复用连接
2. net.ipv4.tcp_tw_recycle = 1; 表示回收连接
3. net.ipv4.tcp_timestamps = 1;


---
### TCP协议的状态(三次握手、四次挥手的装换状态)

---
### 握手/挥手的初始序列号是多少，如何生成的

---
### tcp握手时，还交换了哪些信息？

---
### tcp头部有哪些字段？选项有哪些字段？

---
### TCP的流量控制和拥塞控制分别是怎么实现的？

1. 流量控制：流量控制的目的是防止发送方发送的数据过快，导致接收方来不及处理，从而造成数据丢失。TCP是通过滑动窗口协议实现流量控制的。

> 滑动窗口机制：
- 发送方和接收方各自维护一个窗口大小，表示可以接收或发送的数据量。接收方在每个ACK响应中告知发送方自己当前的接收窗口大小(rwnd)，即它还能接收多少字节的数据；
- 发送方根据接收方报告的窗口大小调整自己的发送速率，确保不会超过接收方的处理能力；

2. TCP拥塞控制：避免过多的数据包同时涌入网络，导致网络资源耗尽、丢包率增加。

> TCP发送方会维持一个拥塞窗口（cwnd）的状态变量，发送方会根据网络的拥塞程度动态调整这个拥塞窗口cwnd值。
TCP的拥塞控制主要采用了四种算法，分别是慢开始、拥塞避免、快重传和快恢复。
 
- 慢启动：慢启动阶段发送方会由小到大逐渐增大发送窗口，cwnd初始值为1，随着每个RTT加倍增长，直到遇到拥塞或者达到慢启动阈值(ssthresh)；
- 拥塞避免：拥塞窗口到了ssthresh的初始值16后会进入拥塞避免阶段，这个阶段拥塞窗口值每经过一个RTT往返窗口大小加1；
- 快重传：如果发送方连续收到三个重复的ACK，表示某个数据包可能丢失了，则立即重传该丢失的数据包，而不必等到超时；
- 快恢复：在快速重传之后，直接进入拥塞避免阶段，将ssthresh设置为当前cwnd的一半，同时保持当前的cwnd不变，直到所有丢失的数据包都被成功确认。

>BBR:谷歌提出的拥塞控制算法，通过估计瓶颈带宽和最小RTT来优化吞吐量和延迟

>CUBIC: Linux内核使用的默认拥塞控制算法

> 流量控制关注的是不会压垮接收方的缓冲区，是基于接收方的反馈进行调整的；
> 拥塞控制是避免整个网络发生拥塞，是基于网络反馈(如丢包情况)进行动态调整的。

---
### 什么是对称加密和非对称加密？

- 对称加密：就是加密方和解密方使用同一个密钥，发送方使用相应的加密算法和密钥加密，接收方使用相同的解密算法和密钥解密；DES、IDEA、AES、SM1、SM4
- 非对称加密：在对称加密过程中，双方在密钥分发的时候还是有可能泄漏密钥。所以在非对称加密中，接收方生成公钥和私钥，把公钥发送给发送方，发送方使用该公钥加密数据，接收方使用私钥解密数据。RSA、ECC、SM2

> 如果需要进行密钥分发，一定要使用非对称加密。之后再用分发得到的密钥进行对称加密。因为公钥和私钥都是接收方生成的，接收方是知道公钥和私钥的，发送方只知道公钥，只有接收方直到怎么解密。

---
### 什么是公钥和私钥？
1. 公钥：发送方和接收方都拥有的密钥
2. 私钥：只有接收方才拥有的密钥，接收方生成公钥和私钥，把公钥发送给发送方，
发送方使用公钥加密数据，接收方使用私钥解密数据。

---
### 常见的散列算法有哪些？

散列算法是一种将任意长度的数据映射为固定长度输出的函数，生成一个唯一值ID。用于数据完整性校验、密码安全、数据签名等领域。

- MD5：
- SHA：SHA系列

---
### 从输入URL到页面展示的整个过程？

1. 首先在浏览器输入一个域名，浏览器会通过DNS服务获取域名对应的IP地址，查找IP地址时会依次从**浏览器缓存、路由器缓存再到DNS缓存**查找对应的IP地址；
2. 有了服务器的IP地址之后浏览器会向web服务器建立TCP连接，发送一个HTTP请求，请求里面会包含对应的Cookies；
3. 服务器处理请求后，发回响应，然后浏览器显示响应的HTML页面；

> DNS解析 -> TCP连接 -> 发送HTTP请求 -> 服务器处理请求并返回HTTP报文 -> 浏览器解析渲染页面 -> 连接结束

> 在浏览器与服务器发送数据的过程中，会首先使用TCP协议与服务器建立TCP连接，建立TCP连接时会在网络层使用IP协议发送数据，IP数据包在路由器之间传送的时候，会使用OSPF协议进行路由选择，路由器在与服务器通信时需要将ip地址转换为MAC地址，这个时候需要ARP协议，在TCP建立完成后，使用HTTP协议访问网页。

---
### HTTP和HTTPS有什么区别？

1. HTTP协议运行在TCP上，数据是明文传输，客户端和服务端都无法验证对方的身份。 
2. HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS运行在TCP之上，所有传输的内容都经过加密，加密使用的密钥使用服务器方的证书进行了非对称加密，所以HTTPS安全性更高；
3. HTTP默认端口号是80，HTTPS默认端口号是443；

---
### http和https区别，怎么加密？
https通过SSL或TLS协议对通信数据进行了加密。
1. 握手阶段：客户端发送连接请求，服务器发送公钥和证书信息，客户端收到证书信息和公钥后，验证证书是否合法，然后生成私钥，将私钥用公钥加密传给服务器。
2. 加密传输阶段：服务器用收到的私钥开始和客户端进行加密通信。

---
### HTTPS原理


---
### HTTP如何保存用户状态？

HTTP是无状态协议，通过Session机制保存用户状态，Session的作用主要是通过服务端记录用户的状态，服务端给用户创建特定的Session之后就可以标识这个用户并且跟踪用户的行为。因为Session是保存在服务端的，如果要对Session跟踪的话，需要在Cookie中附加一个Session ID。

---
### Cookie和Session有什么区别？分别适用什么场景？
都可以跟踪用户状态，在客户端和服务端之间传递数据
1. 存储位置不同：Cookie存储在客户端浏览器中的文本文件，而Session是存储在服务器端的内存中或数据库中
2. 存储内容不同：Cookie主要存储一些简单的信息，比如用户ID，但是Session主要存储复杂的数据结构，比如对象、数组等
3. 安全性不同：Cookie中存储的数据可以被客户端修改，安全性较低；而session 存储在服务器端，客户端无法直接修改，安全性较高
4. 生命周期不同：Cookie可以设置过期时间，可以在客户端存储一段时间，即使关闭浏览器也不会失效；而session的生命周期通常是一次会话，当用户关闭浏览器或者超时，session就会失效
5. 传递方式不同：cookie是通过http头部传递的，每次请求都会发送到服务器端；而session是通过服务器端的session id传递的，客户端只需要保存session id即可。

> cookie通常用于个性化设置、广告追踪、登录信息，更适合存不敏感数据；  

> session也是实现用户登录、购物车、多个页面表单填写信息、在线支付等场景，更适合处理敏感信息。

> 可以用Cookie存储Session ID，即便捷又保障了Session的安全。

---
### HTTP的服务端生成了一个Cookie，如何传给客户端？
1. 服务端的Cookie会通过HTTP响应报文头部的set-cookie字段传给客户端，cookie-name：cookie-value这样设置cookie的值；
2. 浏览器收到cookie之后，在下次请求的时候请求报文就会将cookie放在HTTP头部的cookie字段，实现身份验证。

---
### URI和URL的区别是什么？

- URI 统一资源标识符，可以唯一标识一个资源，表示资源的位置、资源的名称、版本、协议等信息。
- URL 统一资源定位符，不仅唯一标识一个资源，还提供这个资源的定位

---
### redis服务挂了，新的连接发生，三次握手是直接被内核检测发送rst还是超时重传的阻塞？

如果服务端挂了，客户端会重传，达到最大重传次数之后就会返回connection timeout连接超时的错误。

但是如果redis进程挂了，但是端口还没有释放，这个时候会服务端会直接返回rst包，表示端口不可达，客户端会收到connection refused错误。

> rst包TCP处理异常连接时的包，快速终止错误连接、响应错误请求。


---
### 讲一讲IP重组？如何保证重组的顺序呢？

当IP数据包的大小超过MTU时候，会对IP数据报进行分片。

主要依靠IP首部的三个字段：
1. 标识字段，同一个IP包的标识字段相同；
2. 标志位，MF和DF位，MF为为1表示后续还有分片，为0表示当前是最后一个分片
3. 片偏移：表示在原始数据包中的偏移量

---
### TCP三次握手最后一次没连上

---
### session和cookie


---
### IO多路复用

---
### BIO，NIO，AIO的区别

---
### 了解Nginx原理吗？Nginx IO模型是什么？

---
### Netty？优势在哪？

---
### 了解netty的内存分配吗？怎么处理粘包和拆包

---
### Http可以基于UDP吗？有什么好处

---
### select、poll、epoll底层，区别是什么？

---
### tcp半连接、全连接

---
### netstat 什么情况下会有timewait

netstat是查看TCP连接的命令。
```shell
# 查看处于TIME_WAIT状态的TCP连接
netstat -nat | grep TIME_WAIT
```

**为什么会有TIME_WAIT状态的连接:**
TCP关闭的过程中客户端最后就是会处于TIME_WAIT状态，为了确保服务端收到了最后的ACK确认，因为如果服务端没有收到ACK确认，服务端会再发一个FIN包，这个时候客户端就可以收到这个FIN包。

**有很多TIME_WAIT状态的TCP连接是什么情况：**
说明服务器处理了大量的HTTP请求，建立了很多TCP短连接，客户端没有用连接池，或者没有用长连接，也可能导致这个问题。

**怎么处理：**
1. 调整配置，让服务器可以重用处于TIME_WAIT状态的连接；
2. 减少TIME_WAIT等待时间；
3. 客户端使用连接池；
4. 使用HTTP keep-alive长连接。
