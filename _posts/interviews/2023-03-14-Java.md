---
title: Java基础
author: Yu Mengchi
categories:
  - Interview 
  - 面试知识点
  - Java基础
tags:
  - Interview
  - Java
---
  
# Java基础面试题

---

### 写一端10个线程之间轮流打印数字0-9的程序？

---

### 写一段单例模式代码？为什么要使用这种加锁模式？

---

### 线程池如何使用，每个参数表示什么？

---

### 使用多线程应该注意的事项？

---

### JVM的内存模型？

- 程序计数器：作为当前线程所执行的字节码的行号指示器。选择下一条需要执行的字节码指令。
- java虚拟机栈：描述java方法执行的内存模型，每个方法执行的同时都会创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等信息。
- 本地方法栈：和虚拟机栈作用类似，虚拟机栈是为执行java方法服务，本地方法栈是为虚拟机使用到的本地方法服务。
- 堆：基本上所有的对象实例和数组都在堆上分配，是垃圾收集的主要区域。
- 方法区：和堆一样也是线程共享的区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 运行时常量池：方法区的一部分。
- 直接内存：不是虚拟机运行时数据区的一部分。jdk8以后方法区的实现元数据区就是位于直接内存中，而不是java堆中。
### 字节码文件如何被jvm读取的？
jvm会通过类加载机制把类的数据从字节码文件加载到内存，并对数据进行校验、转换解析和初始化，最后
形成可以被虚拟机直接使用的java类型。
加载的过程可以分为加载、验证、准备、解析、初始化、使用、最后卸载。
- 加载阶段jvm会获取字节码文件，首先通过类的全限定名来获取该类的二进制字节流。然后将这个字节流
所代表的静态结构转化成方法区的运行时数据结构。最后在内存中生成一个代表这个类的Class对象，作为方法区
的这个类的各种数据的访问入口。
- 验证阶段对字节流进行验证，确保符合java虚拟机规范，保证字节码格式正确。
- 准备阶段为类变量(静态变量)分配内存和初始化值的过程，

### 编译的字节码文件中的主要内容是什么？
魔数 
次版本号 
主版本号 
文件信息 
常量池 
方法表集合（对类内部的方法描述，在字节码中以表的集合形式表现）

### jvm优化；


### 如何排查oom
一些常用的JVM配置参数
- -Xmx(堆内存最大值) 4g  -Xms(堆内存初始值大小) 4g 设置堆内存
- -XX：UseG1GC -XX：MaxGCPauseMIllis=50  指定GC算法
- -XX：ParallelGCThreads=4 指定GC并行线程数
- -XX：+PrintGCDetails -XX：PrintGCDateStamps   打印GC日志
- -Xloggc:gc.log  指定GC日志文件
- -XX：MaxMetaspaceSize=2g   指定Meta区的最大值
- -Xss 1m  设置单个线程栈的大小
- -XX：+HeapDumpOnOutOfMemoryError  -XX：HeapDumpPath=/usr/local/  指定堆内存溢出时自动进行Dump

### jvm工具
- jps：与linux上的ps类似，可以查看虚拟机的进程，可以查看本地运行着几个java程序，并显示他们的进程号。
- jstat：监视jvm内存内的各种堆和非堆的大小及其内存使用量
- jstack：堆栈跟踪工具，一般用于查看某个进程包含线程的情况
- jmap：打印出某个java进程内存内的所有对象的情况。一般用于查看内存占用情况。生产堆转储文件
- jinfo：可以输出并修改运行时的java进程的一些参数
- jconsole：一个java GUI监视工具，可以以图表化的形式显示各种数据，并可通过远程连接监视远程的服务器的jvm进程。


- top：查看当前所有进程的使用情况，cpu占用率、内存使用情况、服务器负载状态等参数
- ps：
### synchronized与lock区别
1. 锁的获取和释放方式不同，lock需要显示获取和释放
2. synchronized是关键字，存在jvm层面，lock时java中一个接口
3. synchronized在获取锁失败的时候会一直等待，直到获取锁。而lock可以设置等待时间，也可以在等待过程中中断线程
4. synchronized是非公平锁，不保证等待时间最长的线程最先获取锁，而lock可以通过构造函数指定锁的公平性

### java 多线程的同步机制
- 同步方法
- 同步代码块
- volatile
- 使用重入锁ReentrantLock同步
- ThreadLocal类

### ThreadLocal类什么情况出现线程安全问题？如何解决？
ThreadLocal可以实现线程本地存储，把共享数据的可见范围限制在一个线程里面，这样的话不需要同步操作也能保证数据互不影响。
原理就是每个线程里面都有一个ThreadLocalMap对象，map里存放了所使用的ThreadLocal对应的value值，每次线程调用get或set方法的时候都会先获取
线程对应的ThreadLocalMap，然后对map里的键值对修改。
可能出现内存泄漏的问题，解决方法就是每次使用完ThreadLocal后执行remove操作。
### AQS是如何实现的？
AQS是juc里的一个抽象基类，可以在多线程环境下实现线程安全和并发控制。
AQS内部是一个存放等待线程的双向链表，有一些原子操作实现对状态的管理。AQS定义了一些方法比如acquire、release等，不同的同步器子类可以实现这些方法实现
不同的同步策略。

### CAS操作
CAS操作是一种原子指令，用于解决并发环境下共享数据的原子更新问题。juc里的原子类会使用到CAS操作。
操作包含三个操作数：内存位置（或者说变量）、预期值和新值。
执行过程的话：
1. 首先会读取当前内存位置的值，保存下来作为预期值
2. 然后在写入的时候，会比较预期值和当前内存位置上的值是不是相等，如果相等，说明没有其他线程修改过，将新值写入到内存位置，更新完成；
3. 如果不想等，说明有其他线程修改过，本次cas操作失败，需要重试。

### volatile的实现原理

volatile是java中用来修饰变量的一个关键字，可以保证线程之间变量的可见性和有序性
1. 可见性就是说当一个线程修改了volatile变量的值的时候，这个变量的新值会立即写回到主内存，这样的话就可以确保不同线程对变量的读取操作都能获取到最新的值。
实现可见性的原理就是java内存模型中规定当一个线程要读取volatile变量的时候，会直接从主内存中获取最新的值，而不是从线程的本地内存中获取，
同样要修改volatile变量的时候，会立即将新值写回到主内存，这样的话就能保证其他线程看到最新的值。
2. 有序性就是说，在进行读取和修改volatile变量的时候，会按照在代码中的顺序执行，不会和其他指令发生重排序，保证了操作的有序性。
实现的原理就是volatile变量会使用内存屏障的机制来禁止指令重排序。在volatile变量的读写操作前后会插入相应的内存屏障，确保所有的读写操作都按照代码的顺序执行。

但是volatile关键字没法保证原子性，也就是说当多个线程同时对volatile变量进行操作时，还是有可能出现竞争的情况。
如果需要保证原子性的话，可以考虑使用锁或者原子类来替代volatile。

### java 锁的实现原理

java提供了两种方式来加锁:synchronized、ReentrantLock
- synchronized修饰对象时：如果修饰的是对象，那么他是依赖于monitor对象-监视器锁来实现锁的机制的。
每个对象都是一个监视器锁（monitor），当monitor被其他线程占用时就会处于锁定状态，线程执行monitorenter
指令时尝试获取monitor的所有权。
线程退出monitor的时候，执行monitorexit指令。
> synchronized的实现原理：synchronized的语义底层是通过一个monitor对象来完成，其实wait/notify等方法也依赖于monitor对象。

- synchronized修饰方法时：那么则是通过ACC_SYNCHRONIZED标识符来进行加锁的。

首先synchronized是java中的一个关键字，一般用来修饰实例方法或同步代码块，实现线程同步。保证多线程访问同步代码的时候只有一个线程能获取到资源。
synchronized的底层实现是基于对象在内存中的存储格式来实现的， 一个java对象主要是由对象头和对象监视器monitor组成：
1. 对象头里有header、实例数据、对齐填充数据。对象头里又有类型指针、标记字段mark word，
   标记字段里会存放对象运行时的一些状态信息，比如哈希码、GC分代年龄、锁的状态标志等，
2. monitor就是对象监视器，线程会通过monitor enter和monitor exit指令来获取和释放锁对象。

无锁：没有对资源锁定，所有线程都能同时访问修改对象，但同时只能有一个修改成功。
偏向锁：只有一个线程进入同步代码，
轻量级锁：其他线程会通过自旋的方式获取锁，不会发生阻塞
重量级锁：原始的synchronized实现，其他线程会阻塞，只有当前线程释放锁，才会唤醒。

### gc算法有哪些？

- 标记-清除算法：首先遍历内存空间，标记还在被引用的对象，然后清除所有未标记的对象。该算法的缺点是会产生内存碎片，影响内存利用效率。
- 复制算法：将内存空间分成相等的两部分，每次只使用其中一部分，当一部分内存使用完之后，将存活的对象复制到另一半内存中，然后清除该部分内存中的所有对象。
该算法的缺点是每次只能使用一般的内存空间，适用于存活对象比较少的情况。
- 标记-整理算法：首先进行标记，然后将所有存活的对象移动到内存的一端，然后清除另一端的所有对象。这个算法的优点是不会产生内存碎片，但是需要移动对象，影响效率。
- 分代收集算法：将内存分成多个代，每个代存活时间不同，每次只对某些代进行垃圾回收。通常将新对象分配到年轻代中，老对象分配到老年代中。
这个算法的优点是能够针对不同的对象进行优化，提高效率。

### 说一下快排思路？

快排的基本思想就是选择一个基准元素，然后将数组划分为两个子数组，使一个子数组中的元素都小于基准元素，另一个子数组中的元素都大于基准元素，然后对两个子数组递归进行快速排序，最后将两个子数组合并起来。

具体的实现过程如下：
1. 选择基准元素：从待排序数组中选择一个元素作为基准元素，通常是选择第一个元素或最后一个元素。
2. 然后划分子数组：将数组中的其余元素划分成两个子数组，其中一个子数组中的所有元素都小于基准元素，另一个子数组中的所有元素都大于基准元素，基准元素的位置也就确定了。
3. 然后递归排序子数组：对两个子数组分别递归进行快速排序，直到子数组中只剩下一个元素或没有元素。
4. 最后合并子数组：将已经排序好的两个子数组合并起来，得到最终的排序结果。

### 线程池原理？

线程池可以在程序运行时预先创建一定数量的线程池对象，然后在需要处理任务时，将任务分配给线程池中的工作线程来执行。

线程池的主要原理如下：
1. 首先线程池池对象初始化：线程池初始化会创建一定数量的线程池对象，同时根据需要设置线程池的最大线程数、空闲线程存活时间等参数；
2. 任务提交：当有任务需要处理的时候，可以通过线程池的submit()方法将任务提交给线程池，线程池会获取一个空闲的线程来处理任务；
3. 任务处理：工作线程会执行任务的run()方法，并将执行结果返回给线程池。
4. 线程池关闭：当不再需要线程池的时候，可以通过线程池的shutdown()方法来关闭线程池。线程池会停止接收新任务，并等待所有正在执行任务执行完成后再关闭线程池。

使用线程池可以提高程序的性能和响应速度，减少线程创建和销毁的开销。同时，线程池还可以控制线程的并发数量，避免资源的浪费和系统的过载。

### 有哪些使用原则，怎么设置几个参数？任务队列中任务太多了有什么影响？如果有100个任务，10个核心线程池大小、20个最大线程池大小、无界任务队列

### HashMap底层原理？
底层是Entry类型的数组+链表和红黑树来实现的。会使用拉链法解决哈希冲突。同一个链表中存放哈希值和散列桶取模运算结果相同的Entry。

### 有没有用过其他框架的HashMap？比如guava模块里的？

### HashMap的loadFactor值为什么是0.75?
loadFactor值表示哈希表中存储元素的数量与哈希表大小的比率。当哈希表中存储的元素数量超过了负载因子乘以哈希表大小的阈值时，哈希表就需要进行扩容了。

### 快排原理？
快排的基本思想是分治法，排序过程如下在输入数组中随机选取一个元素作为中间值pivot，然后对数组进行分区partition，使所有比中间值小的数据移到数组的左边，
所有比中间值大的数据移到数组的右边。接下来对中间值左右两侧的子数组用相同的步骤排序，直到子数组中只有一个数字为止。
### 快排，数组对于快排的影响？
快排的时间复杂度取决于所选取的中间值在数组中的位置。如果每次选取的中间值在排序数组中都接近数组中间的位置，那么快速排序的时间复杂度是O(nlogn)。
如果每次选取的中间值都位于排序数组的头部或尾部，那么快速排序的时间复杂度是O(n^2)。这也是随机选取中间值的原因，避免在某些情况下快速排序退化成时间复杂度为O(n^2)的算法。

### Collections中采用的排序方式是哪一种？具体是怎么使用的？
mergeSort和TimSort

### 归并排序的应用场景？空间复杂度？快排的空间复杂度是多少？
归并时间复杂度O(nlogn),空间复杂度O(n)，需要辅助数组  
快排平均时间复杂度O(nlogn)，最坏O(n^2)，空间复杂度平均O(logn),最坏O(n)
