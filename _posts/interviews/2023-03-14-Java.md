---
title: Java基础
author: Yu Mengchi
categories:
  - Interview 
  - 面试知识点
  - Java基础
tags:
  - Interview
  - Java
---
  
# Java基础面试题

---

### 写一端10个线程之间轮流打印数字0-9的程序？

---

### 写一段单例模式代码？为什么要使用这种加锁模式？

---

### 线程池如何使用，每个参数表示什么？

---

### 使用多线程应该注意的事项？

---

### JVM的内存模型？

- 程序计数器：作为当前线程所执行的字节码的行号指示器。选择下一条需要执行的字节码指令。
- java虚拟机栈：描述java方法执行的内存模型，每个方法执行的同时都会创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等信息。
- 本地方法栈：和虚拟机栈作用类似，虚拟机栈是为执行java方法服务，本地方法栈是为虚拟机使用到的本地方法服务。
- 堆：基本上所有的对象实例和数组都在堆上分配，是垃圾收集的主要区域。
- 方法区：和堆一样也是线程共享的区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 运行时常量池：方法区的一部分。
- 直接内存：不是虚拟机运行时数据区的一部分。jdk8以后方法区的实现元数据区就是位于直接内存中，而不是java堆中。

---

### Java的内存结构

---

### Java的类加载过程？

---


### java一次编译到处运行的原因？
在不同平台有不同的JVM虚拟机，都可以载入和执行字节码文件

### 字节码文件如何被jvm读取的？
jvm会通过类加载机制把类的数据从字节码文件加载到内存，并对数据进行校验、转换解析和初始化，最后
形成可以被虚拟机直接使用的java类型。
加载的过程可以分为加载、验证、准备、解析、初始化、使用、最后卸载。
- 加载阶段jvm会获取字节码文件，首先通过类的全限定名来获取该类的二进制字节流。然后将这个字节流
所代表的静态结构转化成方法区的运行时数据结构。最后在内存中生成一个代表这个类的Class对象，作为方法区
的这个类的各种数据的访问入口。
- 验证阶段对字节流进行验证，确保符合java虚拟机规范，保证字节码格式正确。
- 准备阶段为类变量(静态变量)分配内存和初始化值的过程，

### 编译的字节码文件中的主要内容是什么？
魔数 
次版本号 
主版本号 
文件信息 
常量池 
方法表集合（对类内部的方法描述，在字节码中以表的集合形式表现）

### jvm优化；


### 如何排查oom
一些常用的JVM配置参数
- -Xmx(堆内存最大值) 4g  -Xms(堆内存初始值大小) 4g 设置堆内存
- -XX：UseG1GC -XX：MaxGCPauseMIllis=50  指定GC算法
- -XX：ParallelGCThreads=4 指定GC并行线程数
- -XX：+PrintGCDetails -XX：PrintGCDateStamps   打印GC日志
- -Xloggc:gc.log  指定GC日志文件
- -XX：MaxMetaspaceSize=2g   指定Meta区的最大值
- -Xss 1m  设置单个线程栈的大小
- -XX：+HeapDumpOnOutOfMemoryError  -XX：HeapDumpPath=/usr/local/  指定堆内存溢出时自动进行Dump

### jvm工具
- jps：与linux上的ps类似，可以查看虚拟机的进程，可以查看本地运行着几个java程序，并显示他们的进程号。
- jstat：监视jvm内存内的各种堆和非堆的大小及其内存使用量
- jstack：堆栈跟踪工具，一般用于查看某个进程包含线程的情况
- jmap：打印出某个java进程内存内的所有对象的情况。一般用于查看内存占用情况。生产堆转储文件
- jinfo：可以输出并修改运行时的java进程的一些参数
- jconsole：一个java GUI监视工具，可以以图表化的形式显示各种数据，并可通过远程连接监视远程的服务器的jvm进程。


- top：查看当前所有进程的使用情况，cpu占用率、内存使用情况、服务器负载状态等参数
- ps：
### synchronized与lock区别


### 三次握手与四次挥手


### 外键的优缺点


### 项目里建了哪些表？


### 字节码的注入技术有没有了解？

---

### java 多线程的同步机制
- 同步方法
- 同步代码块
- volatile
- 使用重入锁ReentrantLock同步
- ThreadLocal类
---

### java 锁的实现原理

java提供了两种方式来加锁:synchronized、ReentrantLock
- synchronized修饰对象时：如果修饰的是对象，那么他是依赖于monitor对象-监视器锁来实现锁的机制的。
每个对象都是一个监视器锁（monitor），当monitor被其他线程占用时就会处于锁定状态，线程执行monitorenter
指令时尝试获取monitor的所有权。
线程退出monitor的时候，执行monitorexit指令。
> synchronized的实现原理：synchronized的语义底层是通过一个monitor对象来完成，其实wait/notify等方法也依赖于monitor对象。
- synchronized修饰方法时：那么则是通过ACC_SYNCHRONIZED标识符来进行加锁的。
---

### gc算法有哪些？

- 标记-清除算法：首先遍历内存空间，标记还在被引用的对象，然后清除所有未标记的对象。该算法的缺点是会产生内存碎片，影响内存利用效率。
- 复制算法：将内存空间分成相等的两部分，每次只使用其中一部分，当一部分内存使用完之后，将存活的对象复制到另一半内存中，然后清除该部分内存中的所有对象。
该算法的缺点是每次只能使用一般的内存空间，适用于存活对象比较少的情况。
- 标记-整理算法：首先进行标记，然后将所有存活的对象移动到内存的一端，然后清除另一端的所有对象。这个算法的优点是不会产生内存碎片，但是需要移动对象，影响效率。
- 分代收集算法：将内存分成多个代，每个代存活时间不同，每次只对某些代进行垃圾回收。通常将新对象分配到年轻代中，老对象分配到老年代中。
这个算法的优点是能够针对不同的对象进行优化，提高效率。

### 说一下快排思路？

快排的基本思想就是选择一个基准元素，然后将数组划分为两个子数组，使一个子数组中的元素都小于基准元素，另一个子数组中的元素都大于基准元素，然后对两个子数组递归进行快速排序，最后将两个子数组合并起来。

具体的实现过程如下：
1. 选择基准元素：从待排序数组中选择一个元素作为基准元素，通常是选择第一个元素或最后一个元素。
2. 然后划分子数组：将数组中的其余元素划分成两个子数组，其中一个子数组中的所有元素都小于基准元素，另一个子数组中的所有元素都大于基准元素，基准元素的位置也就确定了。
3. 然后递归排序子数组：对两个子数组分别递归进行快速排序，直到子数组中只剩下一个元素或没有元素。
4. 最后合并子数组：将已经排序好的两个子数组合并起来，得到最终的排序结果。

### 线程池原理？

线程池可以在程序运行时预先创建一定数量的线程池对象，然后在需要处理任务时，将任务分配给线程池中的工作线程来执行。

线程池的主要原理如下：
1. 首先线程池池对象初始化：线程池初始化会创建一定数量的线程池对象，同时根据需要设置线程池的最大线程数、空闲线程存活时间等参数；
2. 任务提交：当有任务需要处理的时候，可以通过线程池的submit()方法将任务提交给线程池，线程池会获取一个空闲的线程来处理任务；
3. 任务处理：工作线程会执行任务的run()方法，并将执行结果返回给线程池。
4. 线程池关闭：当不再需要线程池的时候，可以通过线程池的shutdown()方法来关闭线程池。线程池会停止接收新任务，并等待所有正在执行任务执行完成后再关闭线程池。

使用线程池可以提高程序的性能和响应速度，减少线程创建和销毁的开销。同时，线程池还可以控制线程的并发数量，避免资源的浪费和系统的过载。


### HashMap底层原理？

