---
title: 动态规划与贪婪算法
author: Yu Mengchi
categories:
  - 算法
  - 剑指offer-第二版
  - 动态规划与贪婪算法 
tags:
  - Interview
  - 算法
  - 动态规划与贪婪算法
---
  
## 面试题14：剪绳子

### 思路

长度为n的绳子，能剪成的最大乘积是多少。
f(n) = Max(f(n-1)*f(1) , f(n-2)*f(2), f(n-3)*f(3),...)
     = Max(f(i)*f(n-i))

一定要从i=4开始循环
```java
public class Solution {
    public int cutRope(int target) {
        int[] dp = new int[target+1];
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 3;
        for (int i = 4; i <= target; i++) {
            for (int j = 1; j <= i/2; j++) {
                dp[i] = Math.max(dp[i], dp[j]*dp[i-j]);
            }
        }
        return dp[target];
    }
}
```

# 位运算

## 面试题15：二进制中1的个数

### 思路

每执行一次 n & (n-1) 运算，n最右边的1就会变为0，我们可以一直执行该操作，直到n变为0。
统计共执行了多少次运算，就有多少个1；

```java
public class Solution {
    public int NumberOf1(int n) {
        int count = 0;
        while (n != 0) {
            n = n & (n-1);
            count++;
        }
        return count;
    }
}
```

# 第三章：高质量的代码

---

## 面试题16：数值的整数次方

要考虑的问题有：
- 指数为负数怎么办
- 求指数如何快速

```java
public class Solution {
    public double Power(double base, int exponent) {
        boolean isNeg = false;
        if (exponent < 0) {
            isNeg = true;
            exponent = -exponent;
        }
        return isNeg ? 1.0 / helper(base, exponent) : helper(base, exponent);
  }

  private double helper(double base, int exponent) {
    if (exponent == 0) {
        return 1.0;
    }
    if (exponent == 1) {
        return base;
    }
    double half = helper(base, exponent / 2);
    double res = half * half;
    if ((exponent & 1) == 1) {
        res = res * base;
    }
    return res;
  }
}
```
## 面试题17：打印从1到最大的n位数

### 思路

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param n int整型 最大位数
     * @return int整型一维数组
     */
    public int[] printNumbers (int n) {
        // write code here
        if (n < 0) {
            return new int[]{};
        }
        char[] num = new char[n];
        List<Integer> list = new LinkedList<>();
        helper(num, 0, list);
        return list.stream().mapToInt(i->i).toArray();
    }
    private void helper(char[] num, int index, List<Integer> list) {
        if (index == num.length) {
            int x = Integer.parseInt(new String(num));
            if (x != 0) {
                list.add(x);
            }
            return;
        }
        for (int i = 0; i < 10; i++) {
            num[index] = (char)(i + '0');
            helper(num, index+1, list);
        }
    }
}
```

## 面试题18：删除链表的节点

### 思路

- 将要删除节点的下一个节点的内容复制到自己节点，然后删除下一个节点
- 如果要删除节点是尾节点，则只能从头开始找前一个节点
- 如果只有一个节点，并且要删除头节点，则直接返回null

leetcode 上参数是给定的数值，不是要删除的节点，所以没法用上面的。
```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 *   public ListNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param head ListNode类 
     * @param val int整型 
     * @return ListNode类
     */
    public ListNode deleteNode (ListNode head, int val) {
        // write code here
        if (head == null) {
            return null;
        }
        if (head.val == val) {
            return head.next;
        }
        
        ListNode cur = head;
        while(cur.next != null) {
            if (cur.next.val == val) {
                ListNode tmp = cur.next;
                cur.next = tmp.next;
                tmp.next = null;
            }
            cur = cur.next;
        }
        return head;
    }
}
```
如果是给定待删除的节点，那么应该用下面的解法
> 按是不是尾节点分，再按是不是头节点分。

```java
    public ListNode deleteNode(ListNode head, ListNode toBeDeleted) {
        if (head == null || toBeDeleted == null) {
            return null;
        }
        if (toBeDeleted.next != null) {//不是尾节点
            ListNode next = toBeDeleted.next;
            toBeDeleted.val = next.val;
            toBeDeleted.next = next.next;
        } else {
            //是尾节点，并且还是头节点
            if (toBeDeleted.val == head.val) {
               head = null; 
            } else {
                ListNode cur = head;
                while (cur.next != toBeDeleted) {
                    cur = cur.next;
                }
                cur.next = null;
            }
        }
        return head;
    }
```

## ！【背】面试题19：正则表达式匹配

### 思路

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();
        boolean[][] dp = new boolean[m+1][n+1];
        dp[0][0] = true;
        for (int j = 1;j<=n;j++) {
            if (p.charAt(j-1) == '*') {
                if (j==1) {
                    dp[0][1] = true;
                } else {
                    dp[0][j] = dp[0][j-2];
                }
            }
        }
        for (int i = 1; i<=m; i++) {
            for (int j = 1; j<=n; j++) {
                if (s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == '.') {
                    dp[i][j] = dp[i-1][j-1];
                } else if (p.charAt(j-1) == '*') {
                    dp[i][j] = dp[i][j-2]; //匹配0个
                    if (s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == '.') {
                        dp[i][j] = dp[i][j] || dp[i][j-1] || dp[i-1][j];
                    }
                }
            }
        }
        return dp[m][n];
    }
}
```
## 面试题20：表示数值的字符串

### 思路

```java
class Solution {
    public boolean isNumber(String s) {
        if (s == null) {
            return false;
        }
        s = s.trim();
        if (s.length() == 0) {
            return false;
        }
        int[] i = {0};
        boolean numeric = scanInteger(s, i);
        

        if (i[0] < s.length() && s.charAt(i[0]) == '.') {
            i[0]++;
            numeric = scanUnsignedInteger(s, i) || numeric;
        }


        if (i[0] < s.length() && (s.charAt(i[0]) == 'e' || s.charAt(i[0]) == 'E')) {
            i[0]++;
            numeric = numeric && scanInteger(s, i);
        }
        return numeric && i[0] == s.length();
    }

//判断s前面是不是有若干个0～9的数字
    private boolean scanUnsignedInteger(String s, int[] i) {
        int before = i[0];
        while (i[0] < s.length() && s.charAt(i[0]) >= '0' && s.charAt(i[0]) <= '9') {
            char ch = s.charAt(i[0]);
                i[0]++;
        }
        return i[0] > before;
    }

    private boolean scanInteger(String s, int[] i) {
        if (i[0] < s.length() && (s.charAt(i[0]) == '+' || s.charAt(i[0]) == '-')) {
            i[0]++;
        }
        return scanUnsignedInteger(s, i);
    }
}
```

下面用正则表达式的方法在用例为".1"的时候会出错。不知道是哪里不对，应该是不能前面只出现'.'号
```java

    public boolean isNumeric (String s) {
        // write code here
        // if (s==null || s.length() == 0) {
        //     return false;
        // }
        // return s.matches("[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?");

        if (s == null || s.length() == 0)
            return false;
        return new String(s.trim()).matches("[+-]?\\d+(\\.\\d+)?([eE][+-]?\\d+)?");
    }
```
## 面试题21：调整数组顺序使奇数位于偶数前面

### 思路

前后两个指针，当前一个指针直到偶数，后一个指针直到奇数时，交换两个数字

书上没有要求数字的相对顺序不变，可以用下面的方法，用前后双指针。
```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型一维数组 
     * @return int整型一维数组
     */
    public int[] reOrderArray (int[] array) {
        // write code here
        int p = 0;
        int q = array.length - 1;
        while (p < q) {
            while (p < array.length && isOdd(array[p])) {
                p++;
            }
            while (q >= 0 && !isOdd(array[q])) {
                q--;
            }
            if (p < q) {
                int tmp = array[p];
                array[p] = array[q];
                array[q] = tmp;
            }
        }
        return array;
    }

    private boolean isOdd(int num) {
        return (num & 1) == 1;
    }
}
```
但是leetcode和牛客上都要求数字相对顺序不变，所以只能用下面的方法：
- 方法1：先统计奇数个数x，然后将i指向0位置，j指向x位置，然后从头开始遍历，新建一个数组，从i开始的都是奇数，从j开始的都是偶数；
- 方法2：使用冒泡思想，每次都将当前偶数上浮到当前最右边。
下面是方法2的解法，每轮循环都把遇到的偶数放到最有右边。
```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型一维数组 
     * @return int整型一维数组
     */
    public int[] reOrderArray (int[] array) {
        // write code here
        for (int i = array.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (isEven(array[j]) && !isEven(array[j+1])) {
                    swap(array, j, j+1);
                }
            }
        }
        return array;
        
    }

    private boolean isEven(int num) {
        return (num & 1) == 0;
    }

    private void swap(int[] array, int i, int j) {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}
```

## 面试题22：链表中倒数第k个节点

### 思路
这道题考察代码鲁棒性，有多种情况都要考虑清楚
```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 *   public ListNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param pHead ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    public ListNode FindKthToTail (ListNode pHead, int k) {
        // write code here
        if (pHead == null || k <= 0) {
            return null;
        } 
        ListNode p1 = pHead;
        while (p1 != null && k > 0) {
            p1 = p1.next;
            k--;
        }
        if (k > 0) {
            return null;
        }

        ListNode p2 = pHead;
        while (p1 != null) {
            p1 = p1.next;
            p2 = p2.next;
        }
        return p2;
    }
}
```
