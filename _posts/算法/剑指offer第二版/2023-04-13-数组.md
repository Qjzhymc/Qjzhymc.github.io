---
title: 数组
author: Yu Mengchi
categories:
  - 算法
  - 剑指offer-第二版
  - 数组
tags:
  - Interview
  - 算法
  - 数组
---
  
## 面试题3：数组中重复的数字

### 思路
因为要统计每个数字出现的次数，所以一般的思路就是用哈希表统计每个数字出现的次数，这种方法需要有一个哈希表存放数字出现的次数，所以空间复杂度是O(n)，而且也没有利用到"所有数字在0到n-1范围内这个条件"。
另一种思路是:如果n个数字每个数字都只出现一次的话，那么排好序之后，下标为i的数字肯定就是i，但因为有重复数字，所以如果排好序的话肯定有下标为i而数字不是i的情况，

从头到尾遍历每个数字，当扫描到下标为i的数字时，首先比较这个数字（用m表示）是不是等于i。如果是，则接着扫描下一个数字；如果不是，则再拿它和
第m个数字进行比较。如果它和第m个数字相等，就找到了一个重复的数字；如果它和第m个数字不相等，就把第i个数字和第m个数字交换，把m放到属于它的位置。
接下来重复这个比较、交换的过程，直到我们发现一个重复的数字。

```java
public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param numbers int整型一维数组 
     * @return int整型
     */
    public int duplicate (int[] numbers) {
        // write code here
        for (int i = 0; i < numbers.length; i++) {
            if (numbers[i] == i) {
                continue;
            } else {
                int num = numbers[numbers[i]];
                if (num == numbers[i]) {
                    return num;
                } else {
                    swap(numbers, i, numbers[i]);
                }
            }
        }
        return -1;
    }

    private void swap(int[] numbers, int i, int j) {
        int tmp = numbers[i];
        numbers[i] = numbers[j];
        numbers[j] = tmp;
    }
}
```
---
## 面试题4：二维数组中的查找

### 思路
从矩阵的右上角或左下角开始搜索，如果该数字大于要查找的数字，则左移一边；如果该数字小于要查找的数字，则下移一行。
```java
public class Solution {
    public boolean Find(int target, int [][] array) {
        if (array.length == 0 || array[0].length == 0) {
            return false;
        }

        int i = 0;
        int j = array[0].length - 1;
        while (i >=0 && i < array.length && j >= 0 && j < array[0].length) {
            if (array[i][j] == target) {
                return true;
            } else if (array[i][j] < target) {
                i++;
            } else {
                j--;
            }
        }
        return false;
    }
}
```

