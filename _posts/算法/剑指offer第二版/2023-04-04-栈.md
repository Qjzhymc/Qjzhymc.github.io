---
title: 哈希表
author: Yu Mengchi
categories:
  - 算法
  - 栈 
tags:
  - Interview
  - 算法
  - 栈
---
  
---

## 面试题36：后缀表达式

### 思路

一定要注意，减法和除法的时候要注意顺序

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<Integer> stack = new Stack<>();
        for (String token : tokens) {
            switch(token) {
                case "+":
                case "-":
                case "*":
                case "/":
                    int num1 = stack.pop();
                    int num2 = stack.pop();
                    stack.push(calculate(num1, num2, token));
                    break; //记得要加break
                default:
                    stack.push(Integer.parseInt(token));
            }
        }
        return stack.pop();
    }
    public int calculate(int num1, int num2, String operator) {
        switch(operator) {
            case "+":
                return num1 + num2;
            case "-":
                return num2 - num1; //减法的时候要反过来
            case "*":
                return num1 * num2;
            case "/":
                return num2 / num1; //除法的时候要反过来
            default:
                return 0;
        }
    }
}
```

## 面试题37：小行星碰撞

### 思路

```java
class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        Stack<Integer> stack = new Stack<>();
        for (int as : asteroids) {
            //当栈顶向右移动，且as向左移动，并且栈顶行星小
            while (!stack.isEmpty() && stack.peek() > 0 && as < 0 && -as > stack.peek()) {
                stack.pop();
            }
            //如果一个向右，一个向左，并且大小相等
            if (!stack.empty() && as < 0 && stack.peek() == -as) {
                stack.pop();
            } else if (as > 0 || stack.empty() || stack.peek() < 0) { // 其他情况，as入栈
                stack.push(as);
            }
        }
        return stack.stream().mapToInt(i -> i).toArray();

    }
}
```

---

## 面试题38: 每日温度

### 思路

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        //用一个栈保存每日温度在数组中的下标，然后每次取一个温度与栈顶那天的温度比较，如果高，则得到栈顶那天的结果
        int[] result = new int[temperatures.length];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < temperatures.length; i++) {
            //栈顶那天的温度小于今天的温度
            while (!stack.isEmpty() && temperatures[stack.peek()] < temperatures[i]) {
                int prev = stack.peek();
                result[prev] = i - prev;
                stack.pop();
            }
            stack.push(i);
        }
        return result;
    }
}
```
