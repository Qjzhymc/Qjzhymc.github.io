---
title: 树
author: Yu Mengchi
categories:
  - 算法
  - 剑指offer-专项突破版
  - 树 
tags:
  - Interview
  - 算法
  - 树
---
  
## 二叉树的深度优先搜索

### 中序遍历

#### 递归实现

```java
//中序遍历递归版
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> nodes = new LinkedList<>();
    dfs(root, nodes);
    return nodes;
}

private void dfs(TreeNode root, List<Integer> nodes) {
    if (root != null) {
        dfs(root.left, nodes);
        nodes.add(root.val);
        dfs(root.right, nodes);
    }
}
```

#### 基于栈的迭代实现

```java
public List<Integer> inorderTraversal2(TreeNode root) {
    List<Integer> nodes = new LinkedList<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) { //到达最左子节点
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.pop();
        nodes.add(cur.val);
        cur = cur.right;
    }
    return nodes;
}
```

### 前序遍历

#### 递归实现

```java
//前序遍历递归版
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> nodes = new LinkedList<>();
    dfs2(root, nodes);
    return nodes;
}
private void dfs2(TreeNode root, List<Integer> nodes) {
    if (root != null) {
        nodes.add(root.val);
        dfs2(root.left, nodes);
        dfs2(root.right, nodes);
    }
}
```

#### 基于栈的迭代实现

```java
//前序遍历迭代版
public List<Integer> preorderTraversal2(TreeNode root) {
    List<Integer> result = new LinkedList<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) {
            result.add(cur.val); //先加该节点，再到最左节点
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.pop();
        cur = cur.right;
    }
    return result;
}
```

### 后序遍历

#### 递归版

```java
//后序遍历递归版
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> nodes = new LinkedList<>();
    dfs(root, nodes);
    return nodes;
}
private void dfs3(TreeNode root, List<Integer> nodes) {
    if (root != null) {
        dfs(root.left, nodes);
        dfs(root.right, nodes);
        nodes.add(root.val);
    }
}
```

#### 基于栈的迭代版

```java
//后序遍历迭代版
public List<Integer> postorderTraversal3(TreeNode root) {
    List<Integer> result = new LinkedList<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    TreeNode prev = null;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) { //到达最左节点
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.peek();
        if (cur.right != null && cur.right != prev) { //说明cur右子节点的子树还没遍历完
            cur = cur.right;
        } else { 
            stack.pop();
            result.add(cur.val); //说明右子树都遍历完了，现在遍历当前节点
            prev = cur;
            cur = null;
        }
    }
    return result;
}
```

