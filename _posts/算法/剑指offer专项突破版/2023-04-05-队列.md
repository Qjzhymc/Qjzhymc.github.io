---
title: 队列
author: Yu Mengchi
categories:
  - 算法
  - 队列
tags:
  - Interview
  - 算法
  - 队列
---
  
- ArrayList不是队列，他只是列表，没有保证先进先出；LinkedList才是实现了Queue接口的队列
- 队列(实现了Queue接口的都可以，LinkedList、PriorityQueue、ArrayDeque)的添加元素和移除队头元素的方法是offer(),poll()。
当然也可以用add(),remove，但是用add，remove会抛出异常，但用offer,poll就不会，比如向一个空队列调用poll就会返回null，而不是抛出异常。

通常基于队列来实现二叉树的广度优先搜索。从二叉树的根节点开始，先把根节点放入一个队列之中，然后每次从队列中取出一个节点遍历。
如果该节点有左右子节点，则分别将它们添加到队列当中。重复这个过程，直到所有节点都遍历完为止，此时队列为空。实现二叉树
广度优先搜索的经典代码如下所示：
```java
public List<Integer> bfs(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    if (root != null) {
        queue.offer(root);
    }
    List<Integer> result = new ArrayList<>();
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        result.add(node.val);
        
        if (node.left != null){
            queue.offer(node.left);
        }
        if (node.right != null) {
            queue.offer(node.right);
        }
    }
    return result;
}
```

如果需要区分二叉树不同的层，那么最好用两个队列分别存放当前层和下一层的节点。如果当前层对应的队列被清空，那么改层所有的节点就已经被遍历完，可以开始遍历下一层

## 面试题41：滑动窗口的平均值

### 思路

用一个队列保存元素，同时被加一个数都记录所有数的和。

```java
class MovingAverage {
    Queue<Integer> queue;
    int capacity;
    int sum = 0;
    /** Initialize your data structure here. */
    public MovingAverage(int size) {
        capacity = size;
        queue = new LinkedList<>();
    }
    
    public double next(int val) {
        queue.offer(val);
        sum += val;
        if (queue.size() > capacity) {
            sum -= queue.poll();
        }
        //记得转化为double
        return (double)sum / queue.size();
    }
}
```

---

## 面试题42：最近请求次数

### 思路
用一个队列保存t，加入队列头，如果队尾与现在加的时间差超过3000，则将队尾元素移出。
最后返回的是队列的大小

```java
class RecentCounter {
    Queue<Integer> queue;
    int windowSize;

    public RecentCounter() {
        queue = new LinkedList<>();
        windowSize = 3000;
    }
    
    public int ping(int t) {
        queue.offer(t);
        while (queue.peek() + windowSize < t) {
            queue.poll();
        }
        return queue.size();
    }
}
```

---

## 面试题43：在完全二叉树中添加节点

### 思路

用一个队列只保存缺少左子节点或右子节点的节点，如果一个节点既有左子节点，又有右子节点，就从队列中删除。

```java
class CBTInserter {

    private Queue<TreeNode> queue;
    private TreeNode root;

    public CBTInserter(TreeNode root) {
        this.root = root;
        queue = new LinkedList<>();
        queue.offer(root);
        while (queue.peek().left != null && queue.peek().right != null) {
            TreeNode node = queue.poll();
            queue.offer(node.left);
            queue.offer(node.right);
        }
    }
    
    public int insert(int v) {
        TreeNode node = new TreeNode(v);
        TreeNode parent = queue.peek();
        if (parent.left == null) {
            parent.left = node;
        } else {
            parent.right = node;//此时parent左右子节点都有了，需要从队列删除，并把parent的左右子节点加入队列
            queue.poll();
            queue.offer(parent.left);
            queue.offer(parent.right);
        }
        return parent.val;
    }
    
    public TreeNode get_root() {
        return this.root;
    }
}
```

---

## 面试题44：二叉树中每层的最大值

### 思路

结果用一个List<Integer>表示，遍历每一层的最大值，要记录是不是遍历完了该层，此时需要先用一个列表记录下一层节点，当队列为空的时候，说明上一层已经遍历完了，在把列表中的所有节点加入队列。
所以用queue1和queue2两个队列分别存放当前层节点和下一层节点

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        Queue<TreeNode> queue1 = new LinkedList<>();
        Queue<TreeNode> queue2 = new LinkedList<>();
        if (root != null) {
            queue1.offer(root);
        }

        List<Integer> result = new LinkedList<>();

        int max = Integer.MIN_VALUE;

        while (!queue1.isEmpty()) {
            TreeNode node = queue1.poll();
            max = Math.max(max, node.val);
            if (node.left != null) {
                queue2.offer(node.left);
            }
            if (node.right != null) {
                queue2.offer(node.right);
            }
            //在while里面判断是否为空了，
            if (queue1.isEmpty()) {
                result.add(max);
                max = Integer.MIN_VALUE; //max也要记得还原
                queue1 = queue2;
                queue2 = new LinkedList<>();
            }
        }
        return result;
    }
}
```

---

## 面试题45：二叉树最底层最左边的值

### 思路
判断什么时候到最底层和判断什么时候到了下一层一样，queue2的peek()就是最底层最左边的节点

```java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue1 = new LinkedList<>();
        Queue<TreeNode> queue2 = new LinkedList<>();
        if (root != null) {
            queue1.offer(root);
        }
        int bottomLeft = root.val;
        while (!queue1.isEmpty()) {
            TreeNode node = queue1.poll();

            if (node.left != null) {
                queue2.offer(node.left);
            }
            if (node.right != null) {
                queue2.offer(node.right);
            }
            if (queue1.isEmpty()) {
                queue1 = queue2;
                queue2 = new LinkedList<>();
                if (!queue1.isEmpty()) { //如果下一层还有节点，更新最底层最左边节点
                    bottomLeft = queue1.peek().val;
                }
            }
        }
        return bottomLeft;
    }
}
```

---

## 面试题46：二叉树的右侧视图

### 思路

相当于返回每一层最右侧节点值

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> view = new LinkedList<>();
        if (root == null) {
            return view;
        }
        Queue<TreeNode> queue1 = new LinkedList<>();
        Queue<TreeNode> queue2 = new LinkedList<>();
        queue1.offer(root);
        while (!queue1.isEmpty()) {
            TreeNode node = queue1.poll();
            if (node.left != null) {
                queue2.offer(node.left);
            }
            if (node.right != null) {
                queue2.offer(node.right);
            }
            //到达了当前层最右侧
            if (queue1.isEmpty()) {
                view.add(node.val);
                queue1 = queue2;
                queue2 = new LinkedList<>();
            }
        }
        return view;

    }
}
```
