---
title: 回溯法
author: Yu Mengchi
categories:
  - 算法
  - 剑指offer-专项突破版
  - 回溯法
tags:
  - Interview
  - 算法
  - 回溯法
---
  
## 集合的组合、排列

---

## 面试题79：所有子集

### 思路
注意参数是列表时，要加类型
```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new LinkedList<>();
        helper(nums, 0, new LinkedList<Integer>(), result);
        return result;
    }

    private void helper(int[] nums, int index, LinkedList<Integer> subset, List<List<Integer>> result) {
        if (index == nums.length) {
            result.add(new LinkedList<>(subset));
        } else if (index < nums.length) {
            helper(nums, index + 1, subset, result);
            subset.add(nums[index]);
            helper(nums, index + 1, subset, result);
            subset.removeLast();
        }
    }
}
```
---
## 面试题80：包含k个元素的组合

### 思路

```java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> result = new LinkedList<>();
        helper(n, k, 1, new LinkedList<>(), result);
        return result;
    }
    private void helper(int n, int k, int num, LinkedList<Integer> subset, List<List<Integer>> result) {
        if (subset.size() == k) {
            result.add(new LinkedList<>(subset));
        } else {
            if (num <= n) {
                helper(n, k, num + 1, subset, result);
                
                subset.add(num);
                helper(n, k, num + 1, subset, result);
                subset.removeLast();
            }
        }
    }
}
```
---

## 面试题81：允许重复选择元素的组合

### 思路

```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new LinkedList<>();
        helper(candidates, target, 0, new LinkedList<>(), result);
        return result;
    }
    private void helper(int[] candidates, int target, int i, LinkedList<Integer> subset, List<List<Integer>> result) {
        if (target == 0) {
            result.add(new LinkedList<>(subset));
        } else {
            if (i < candidates.length && target > 0) {
                helper(candidates, target, i + 1, subset, result);

                subset.add(candidates[i]);
                helper(candidates, target - candidates[i], i, subset, result); //因为可以重复选，所以下标还是i
                subset.removeLast();
            }
        }
    }
}
```
---
## 面试题82：包含重复元素集合的组合

### 思路

```java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> result = new LinkedList<>();
        helper(candidates, target, 0, new LinkedList<>(), result);
        return result;
    }
    private void helper(int[] candidates, int target, int i, LinkedList<Integer> subset, List<List<Integer>> result) {
        if (target == 0) {
            result.add(new LinkedList<>(subset));
        } else {
            if (target > 0 && i < candidates.length) {
                helper(candidates, target, getNextIndex(candidates, i), subset, result);

                subset.add(candidates[i]);
                helper(candidates, target - candidates[i], i + 1, subset, result);
                subset.removeLast();
            }
        }
    }
    private int getNextIndex(int[] candidates, int i) {
        int j = i + 1;
        while (j < candidates.length && candidates[i] == candidates[j]) {
            j++;
        }
        return j;
    }
}
```
---
## 面试题83：没有重复元素集合的全排列

### 思路
排列和上面几道组合的题目有点不一样
```java
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new LinkedList<>();
        helper(nums, 0, result);
        return result;
    }
    private void helper(int[] nums, int i, List<List<Integer>> result) {
        if (i == nums.length) { //表示len-1位置上的值已经安排好了
            List<Integer> subset = new LinkedList<>();
            for (int num : nums) {
                subset.add(num);
            }
            result.add(subset);
        } else {
            for (int j = i; j < nums.length; j++) {
                swap(nums, i, j);
                helper(nums, i + 1, result);
                swap(nums, i, j); //这一步是回溯
            }
        }
    }
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```
---
## 面试题84：包含重复元素集合的全排列

### 思路
```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> result = new LinkedList<>();
        helper(nums, 0, result);
        return result;
    }
    private void helper(int[] nums, int i, List<List<Integer>> result) {
        if (i == nums.length) {
            List<Integer> subset = new LinkedList<>();
            for (int num : nums) {
                subset.add(num);
            }
            result.add(subset);
        } else {
            Set<Integer> set = new HashSet<>();
            for (int j = i; j < nums.length; j++) {
                if (!set.contains(nums[j])) {
                    set.add(nums[j]);

                    swap(nums, i, j);
                    helper(nums, i + 1, result);
                    swap(nums, i, j);
                }
            }
        }
    }
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```
## 使用回溯法解决其他类型的问题

---
## 面试题85：生成匹配的括号

### 思路

- 什么时候可以用左括号：只要还可以用左括号，就选一个左括号
- 什么时候可以用右括号：只有当剩下的左括号个数小于右括号的时候，才可以选右括号

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new LinkedList<>();
        helper(n, n, "", result);
        return result;
    }
    private void helper(int left, int right, String curStr, List<String> result) {
        if (left == 0 && right == 0) {
            result.add(curStr);
        } else {
            if (left > 0) {
                helper(left - 1, right, curStr + "(", result);
            }
            if (left < right) {
                helper(left, right - 1, curStr + ")", result);
            }
        }
    }
}
```
---
## 面试题86：分割回文子字符串

### 思路

```java
class Solution {
    public String[][] partition(String s) {
        List<List<String>> result = new LinkedList<>();
        helper(s, 0, new LinkedList<>(), result);
        String[][] r = new String[result.size()][];
        for (int i = 0; i < result.size(); i++) {
            List<String> list = result.get(i);
            r[i] = result.get(i).toArray(new String[list.size()]);
        }
        return r;
    }
    private void helper(String s, int index, LinkedList<String> substrings, List<List<String>> result) {
        if (index == s.length()) {
            result.add(new LinkedList<>(substrings));
            return;
        } else {
            for (int j = index; j < s.length(); j++) {
                if (isPalindrom(s, index, j)) {
                    substrings.add(s.substring(index, j + 1));
                    helper(s, j + 1, substrings, result);
                    substrings.removeLast();
                }
            }
        }
    }
    private boolean isPalindrom(String s, int start, int end) {
        while (start < end) {
            if (s.charAt(start++) != s.charAt(end--)) {
                return false;
            }
        }
        return true;
    }
}
```
---
## 面试题87：恢复IP地址

### 思路

```java
class Solution {
    public List<String> restoreIpAddresses(String s) {
        List<String> result = new LinkedList<>();
        helper(s, 0, 0, "", "", result);
        return result;
    }
    private void helper(String s, int i, int segI, String seg, String ip, List<String> result) {
        if (i == s.length() && segI == 3 && isValid(seg)) {
            result.add(ip + seg);
        } else {
            if (segI <= 3 && i < s.length()) {
                char ch = s.charAt(i);
                if (isValid(seg + ch)) {
                    helper(s, i + 1, segI, seg + ch, ip, result);
                }
                if (seg.length() > 0 && segI < 3) {
                    helper(s, i + 1, segI + 1, "" + ch, ip + seg + ".", result);
                }
            }
        }
    }
    private boolean isValid(String s) {
        if ((Integer.valueOf(s) < 256) && (s.charAt(0) != '0' || s.equals("0"))) {
            return true;
        }
        return false;
    }
}
```
