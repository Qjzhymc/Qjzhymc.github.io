---
title: 前n个数字二进制形式中1的个数
author: Yu Mengchi
categories:
  - 算法 
  - 剑指offer-专项突破版
tags:
  - Interview
  - 算法
  - 二进制
  - 整数
---
  
# 面试题3：前n个数字二进制形式中1的个数

---

> 题目：输入一个非负数n，请计算0到n之间每个数字的二进制形式中1的个数，并输出一个数组。例如，输入的n为4，由于0、1、2、3、4的二进制形式中1的个数分别为0、1、1、2、1，因此输出数组[0,1,1,2,1]

---

## 思路

这个题目让我想起了校招面试华为时候面试官出的一道题，就是求一个数的二进制表示中有多少个1，当年太菜了，竟然一点都没有想到用二进制来做。这道题目就是用一个for循环，对于每一个数，计算该数的二进制表示有多少个1组成，然后加入对应数组中。   
先看一下最开始我能想到的方法：如何计算一个数的二进制表示中有多少个1组成这个问题。应该从右到左，判断每一位是不是1。那如何求一个数num的最后一位二进制表示呢？用1和num做与运算，num&1，如果最后一位是0，结果就是0，如果最后一位是1，结果就是1。那么接下来如何把最后一位删掉呢？到这里我就想不出来了。那既然没有什么办法判断删掉num的最后一位，那就用num与10做与运算，num&(10)，
这样结果为00的话说明num倒数第二位是0，结果为10的话num倒数第二位是1。然后再用100判断倒数第三位。1000判断倒数第四位...   

这种做法的问题是
1.首先每一位都要做与判断该位是不是1，则判断一个数num的时间复杂度就是O(n),n位num的二进制表示长度；
2.怎么得到1、10、100、1000、10000...呢？

所以这种做法是肯定通过不了的。书上的解法是，依次删除num最右边的1，直到num变为0，说明num中的1都被删除完了，只要判断删除了多少次，就说明num中有多少1。

![img_1.png](../../../assets/img/img9.png)

因此最终代码如下：

```Java
public static int[] countBits(int num) {
    int[] result = new int[num + 1];
    for (int i = 0; i <= num; i++) {
        int j = i;
        while (j != 0) {
            result[i]++;
            j = j & (j - 1);
        }
    }
    return result;
}
```

这种解法的时间复杂度是O(kn),n表示题目中n数，k表示每个数字平均有多少个1。

还有一种时间复杂度更低的解法，由于我们已经知道num&(num-1)就是num去掉最后一个1所得到的，所以num的1的个数肯定是num&(num-1)的1的个数+1。因此result[num] = result[num&(num-1)] + 1;

- 需要注意一点的是，由于每求一个result[num],都是要求result[num&(num-1)],所以循环的时候num要从1开始算起，如果从0开始算，就是得到result[0]=result[0&(-1)]+1,会出错。

最终代码如下：
```Java
public static int[] countBits(int num) {
    int[] result = new int[num + 1];
    for (int i = 1; i <= num; i++) {
        result[i] = result[i & (i-1)] + 1;
    }
    return result;
}
```
这种时间复杂度是O(n)
