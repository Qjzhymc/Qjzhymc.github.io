---
title: 第二部分
author: Yu Mengchi
categories:
  - 算法
  - 剑指offer-专项突破版
  - 第二部分 
tags:
  - Interview
  - 算法
  - 字符串
  - 双指针
---


## 面试题30 插入、删除和随机访问都是O(1)的容器

### 思路

```java
class RandomizedSet {
    HashMap<Integer, Integer> numToLocation;
    ArrayList<Integer> nums;//数组用ArrayList实现

    /** Initialize your data structure here. */
    public RandomizedSet() {
        numToLocation = new HashMap<>();
        nums = new ArrayList<>();
    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        if (numToLocation.containsKey(val)) {
            return false;
        } else {
            nums.add(val);
            numToLocation.put(val, nums.size() - 1);
            return true;
        }
    }
    
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        if (!numToLocation.containsKey(val)) {
            return false;
        } else {
            //删除一个元素的时候要注意，数组将最后一个元素和待删除元素交换位置，然后直接删除最后一个位置上的元素就行。避免后面的元素移动位置。
            int location = numToLocation.get(val);
            numToLocation.put(nums.get(nums.size() - 1), location);
            numToLocation.remove(val);
            nums.set(location, nums.get(nums.size() - 1));
            nums.remove(nums.size() - 1);
            return true;
        }
    }
    
    /** Get a random element from the set. */
    public int getRandom() {
        Random random = new Random();
        int r = random.nextInt(nums.size());
        return nums.get(r);
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```



## 面试题31： 最近最少使用缓存

### 思路

用哈希表和双向链表实现，哈希表中键是key，值是双向链表的节点；双向链表中一个节点有key，value，next，prev指针。
- 插入元素的时候，如果缓存中有，直接将该节点移到尾节点；如果缓存没有，需要先看缓存时候慢了，如果满了，要先把双向链表中头节点和哈希表中该节点移除，然后插入双向链表尾部。

```java
class LRUCache {

    class ListNode {
        public int key;
        public int value;

        public ListNode next;
        public ListNode prev;
        public ListNode(int k, int v) {
            key = k;
            value = v;
        }
    }

    private ListNode head;
    private ListNode tail;
    private Map<Integer, ListNode> map;
    int cap;

    public LRUCache(int capacity) {
        map = new HashMap<>();
        head = new ListNode(-1, -1);
        tail = new ListNode(-1, -1);
        head.next = tail;
        tail.prev = head;

        cap = capacity; //构造函数的参数和成员变量参数不能相同
    }
    
    public int get(int key) {
        ListNode node = map.get(key);
        if (node == null) {
            return -1;
        }
        moveToTail(node, node.value);
        return node.value;
    }
    
    public void put(int key, int value) {
        if (map.containsKey(key)) {
            moveToTail(map.get(key), value);
        } else {
            if (map.size() == cap) {
                ListNode toBeDeleted = head.next;
                deleteNode(toBeDeleted);
                map.remove(toBeDeleted.key);
            }
            ListNode node = new ListNode(key, value);
            insertToTail(node);
            map.put(key, node);
        }
    }
    //辅助函数
    private void moveToTail(ListNode node, int newValue) {
        deleteNode(node);
        node.value = newValue;
        insertToTail(node);
    }
    private void deleteNode(ListNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    private void insertToTail(ListNode node) {
        tail.prev.next = node;
        node.prev = tail.prev;
        node.next = tail;
        tail.prev = node;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```



## 面试题32：有效的变位词

### 思路

这个题在leetcode和书上有点不一样，leetcode要求字符顺序不完全相同，如果两个字符一样要返回false，书上没考虑这些。

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length() || s.equals(t)) {
            return false;
        }
        Map<Character, Integer> map = new HashMap<>();
        for (char ch : s.toCharArray()) {
            map.put(ch, map.getOrDefault(ch, 0) + 1);
        }
        for (char ch : t.toCharArray()) {
            if (!map.containsKey(ch) || map.get(ch) == 0) {
                return false;
            }
            map.put(ch, map.get(ch) - 1);
        }
        return true;
    }
}
```



## 面试题33：变位词组

### 思路

因为一组变位词将字符串按字母排序后会归为同一个字符串，所以用一个map，key为一组排序后的变位词的字符串，value为该组变位词。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        for (String str : strs) {
            char[] charArray = str.toCharArray();
            Arrays.sort(charArray);
            String sortedStr = new String(charArray);
            map.putIfAbsent(sortedStr, new LinkedList<>());
            map.get(sortedStr).add(str);
        }
        return new LinkedList<>(map.values());
    }
}
```



## 面试题34：外星语言是否排序

### 思路

用一个数组表示每个字符在新排序表中排在什么位置上，数字越小排名越考前

```java
class Solution {
    public boolean isAlienSorted(String[] words, String order) {
        int[] orderArray = new int[order.length()];
        for (int i = 0; i < order.length(); i++) {
            orderArray[order.charAt(i) - 'a'] = i;  //保存当前字母在字母表中的位置
        }

        for (int i = 0; i < words.length - 1; i++) {
            if (!isSorted(words[i], words[i + 1], orderArray)) {
                return false;
            }
        }
        return true;
    }

    public boolean isSorted(String word1, String word2, int[] orderArray) {
        int i = 0;
        for (; i < word1.length() && i < word2.length(); i++) {
            char ch1 = word1.charAt(i);
            char ch2 = word2.charAt(i);
            //这里要注意，如果word1比word2先，那么就可以直接判断是一个合法的顺序了。
            if (orderArray[ch1 - 'a'] < orderArray[ch2 - 'a']) {
                return true;
            }
            if (orderArray[ch1 - 'a'] > orderArray[ch2 - 'a']) {
                return false;
            }
        }
        return i == word1.length();//这里要用到i，所以把i放到for循环外定义
        
    }
}
```



## 面试题35：最小时间差

## 思路

一天有1440个分钟，用一个1440长的数组表示出现的时间，然后计算每个相邻时间的下标之差

```java
class Solution {
    public int findMinDifference(List<String> timePoints) {
        if (timePoints.size() > 1440) {
            return 0;
        }
        boolean[] minuteFlags = new boolean[1440];
        for (String str : timePoints) {
            String t[] = str.split(":");
            int min = Integer.parseInt(t[0]) * 60 + Integer.parseInt(t[1]);
            
            if (minuteFlags[min] == true) { //表示有两个相同的时间
                return 0;
            }
            minuteFlags[min] = true;
        }
        return helper(minuteFlags);
    }

    //找到最近的两个相邻的true，计算下标之差。first表示第一个true的下标，last表示最后一个true的下标。
    public int helper(boolean[] minuteFlags) { 
        int prev = -1;
        int first = minuteFlags.length - 1;
        int last = -1;
        int minDiff = minuteFlags.length - 1;
        for (int i = 0; i < minuteFlags.length; i++) {
            if (minuteFlags[i]) {
                if (prev >= 0) {
                    minDiff = Math.min(minDiff, i - prev);
                }
                prev = i;
                first = Math.min(first, i);
                last = Math.max(last, i);
            }
        }
        minDiff = Math.min(first + minuteFlags.length - last, minDiff);
        return minDiff;
    }
}
```



## 面试题36：后缀表达式

### 思路

一定要注意，减法和除法的时候要注意顺序

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<Integer> stack = new Stack<>();
        for (String token : tokens) {
            switch(token) {
                case "+":
                case "-":
                case "*":
                case "/":
                    int num1 = stack.pop();
                    int num2 = stack.pop();
                    stack.push(calculate(num1, num2, token));
                    break; //记得要加break
                default:
                    stack.push(Integer.parseInt(token));
            }
        }
        return stack.pop();
    }
    public int calculate(int num1, int num2, String operator) {
        switch(operator) {
            case "+":
                return num1 + num2;
            case "-":
                return num2 - num1; //减法的时候要反过来
            case "*":
                return num1 * num2;
            case "/":
                return num2 / num1; //除法的时候要反过来
            default:
                return 0;
        }
    }
}
```

## 面试题37：小行星碰撞

### 思路

```java
class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        Stack<Integer> stack = new Stack<>();
        for (int as : asteroids) {
            //当栈顶向右移动，且as向左移动，并且栈顶行星小
            while (!stack.isEmpty() && stack.peek() > 0 && as < 0 && -as > stack.peek()) {
                stack.pop();
            }
            //如果一个向右，一个向左，并且大小相等
            if (!stack.empty() && as < 0 && stack.peek() == -as) {
                stack.pop();
            } else if (as > 0 || stack.empty() || stack.peek() < 0) { // 其他情况，as入栈
                stack.push(as);
            }
        }
        return stack.stream().mapToInt(i -> i).toArray();

    }
}
```



## 面试题38: 每日温度

### 思路

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        //用一个栈保存每日温度在数组中的下标，然后每次取一个温度与栈顶那天的温度比较，如果高，则得到栈顶那天的结果
        int[] result = new int[temperatures.length];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < temperatures.length; i++) {
            //栈顶那天的温度小于今天的温度
            while (!stack.isEmpty() && temperatures[stack.peek()] < temperatures[i]) {
                int prev = stack.peek();
                result[prev] = i - prev;
                stack.pop();
            }
            stack.push(i);
        }
        return result;
    }
}
```



## 面试题39：直方图最大矩形面积

### 思路

代码中要注意一点是一开始向栈中加入-1，判断是否还有元素时也是判断栈顶元素是不是-1来判断的。

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        //用一个单调递增的栈，存放递增的柱子下标
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);

        int maxArea= 0;
        for (int i = 0; i < heights.length; i++) {
            //栈顶元素比当前元素大，因为要保存栈单调递增，所以弹出栈顶元素
            while (stack.peek() != -1 && heights[stack.peek()] >= heights[i]) {
                int height = heights[stack.pop()];
                int width = i - stack.peek() - 1;
                maxArea = Math.max(maxArea, height * width);   
            }

            stack.push(i);
        }

        while (stack.peek() != -1) {
            int height = heights[stack.pop()];
            int width = heights.length - stack.peek() - 1;
            maxArea = Math.max(maxArea, height * width);
        }
        return maxArea;

    }
}
```




## 面试题40：矩阵中的最大矩形

### 思路

```java
class Solution {
    public int maximalRectangle(String[] matrix) {
        if (matrix.length == 0) {
            return 0;
        }
        int cols = matrix[0].length();
        int[] heights = new int[cols];
        int maxArea = 0;
        for (String str : matrix) {
            if (str.length() != cols) {
                return 0;
            }
            for (int i = 0; i < str.length(); i++) {
                char ch = str.charAt(i);
                if (ch == '0') {
                    heights[i] = 0;
                } else {
                    heights[i]++;
                } 
            }
            //这一句记得放在这里
            maxArea = Math.max(maxArea, getMaxArea(heights));
        }
        return maxArea;
    }
    //这个方法就是上一题求最大矩形的题
    public int getMaxArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        int maxArea = 0;
        for (int i = 0; i < heights.length; i++) {
            while (stack.peek() != -1 && heights[stack.peek()] >= heights[i]) {
                int height = heights[stack.pop()];
                int area = height * (i - stack.peek() - 1);
                maxArea = Math.max(maxArea, area);
            }
            stack.push(i);
        }
        while (stack.peek() != -1) {
            int height = heights[stack.pop()];
            int area = height * (heights.length - stack.peek() - 1);
            maxArea = Math.max(maxArea, area);
        }
        return maxArea;
    }
}
```


- ArrayList不是队列，他只是列表，没有保证先进先出；LinkedList才是实现了Queue接口的队列
- 队列(实现了Queue接口的都可以，LinkedList、PriorityQueue、ArrayDeque)的添加元素和移除队头元素的方法是offer(),poll()。
  当然也可以用add(),remove，但是用add，remove会抛出异常，但用offer,poll就不会，比如向一个空队列调用poll就会返回null，而不是抛出异常。

通常基于队列来实现二叉树的广度优先搜索。从二叉树的根节点开始，先把根节点放入一个队列之中，然后每次从队列中取出一个节点遍历。
如果该节点有左右子节点，则分别将它们添加到队列当中。重复这个过程，直到所有节点都遍历完为止，此时队列为空。实现二叉树
广度优先搜索的经典代码如下所示：
```java
public List<Integer> bfs(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    if (root != null) {
        queue.offer(root);
    }
    List<Integer> result = new ArrayList<>();
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        result.add(node.val);
        
        if (node.left != null){
            queue.offer(node.left);
        }
        if (node.right != null) {
            queue.offer(node.right);
        }
    }
    return result;
}
```

如果需要区分二叉树不同的层，那么最好用两个队列分别存放当前层和下一层的节点。如果当前层对应的队列被清空，那么改层所有的节点就已经被遍历完，可以开始遍历下一层

## 面试题41：滑动窗口的平均值

### 思路

用一个队列保存元素，同时被加一个数都记录所有数的和。

```java
class MovingAverage {
    Queue<Integer> queue;
    int capacity;
    int sum = 0;
    /** Initialize your data structure here. */
    public MovingAverage(int size) {
        capacity = size;
        queue = new LinkedList<>();
    }
    
    public double next(int val) {
        queue.offer(val);
        sum += val;
        if (queue.size() > capacity) {
            sum -= queue.poll();
        }
        //记得转化为double
        return (double)sum / queue.size();
    }
}
```



## 面试题42：最近请求次数

### 思路
用一个队列保存t，加入队列头，如果队尾与现在加的时间差超过3000，则将队尾元素移出。
最后返回的是队列的大小

```java
class RecentCounter {
    Queue<Integer> queue;
    int windowSize;

    public RecentCounter() {
        queue = new LinkedList<>();
        windowSize = 3000;
    }
    
    public int ping(int t) {
        queue.offer(t);
        while (queue.peek() + windowSize < t) {
            queue.poll();
        }
        return queue.size();
    }
}
```



## 面试题43：在完全二叉树中添加节点

### 思路

用一个队列只保存缺少左子节点或右子节点的节点，如果一个节点既有左子节点，又有右子节点，就从队列中删除。

```java
class CBTInserter {

    private Queue<TreeNode> queue;
    private TreeNode root;

    public CBTInserter(TreeNode root) {
        this.root = root;
        queue = new LinkedList<>();
        queue.offer(root);
        while (queue.peek().left != null && queue.peek().right != null) {
            TreeNode node = queue.poll();
            queue.offer(node.left);
            queue.offer(node.right);
        }
    }
    
    public int insert(int v) {
        TreeNode node = new TreeNode(v);
        TreeNode parent = queue.peek();
        if (parent.left == null) {
            parent.left = node;
        } else {
            parent.right = node;//此时parent左右子节点都有了，需要从队列删除，并把parent的左右子节点加入队列
            queue.poll();
            queue.offer(parent.left);
            queue.offer(parent.right);
        }
        return parent.val;
    }
    
    public TreeNode get_root() {
        return this.root;
    }
}
```



## 面试题44：二叉树中每层的最大值

### 思路

结果用一个List<Integer>表示，遍历每一层的最大值，要记录是不是遍历完了该层，此时需要先用一个列表记录下一层节点，当队列为空的时候，说明上一层已经遍历完了，在把列表中的所有节点加入队列。
所以用queue1和queue2两个队列分别存放当前层节点和下一层节点

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        Queue<TreeNode> queue1 = new LinkedList<>();
        Queue<TreeNode> queue2 = new LinkedList<>();
        if (root != null) {
            queue1.offer(root);
        }

        List<Integer> result = new LinkedList<>();

        int max = Integer.MIN_VALUE;

        while (!queue1.isEmpty()) {
            TreeNode node = queue1.poll();
            max = Math.max(max, node.val);
            if (node.left != null) {
                queue2.offer(node.left);
            }
            if (node.right != null) {
                queue2.offer(node.right);
            }
            //在while里面判断是否为空了，
            if (queue1.isEmpty()) {
                result.add(max);
                max = Integer.MIN_VALUE; //max也要记得还原
                queue1 = queue2;
                queue2 = new LinkedList<>();
            }
        }
        return result;
    }
}
```



## 面试题45：二叉树最底层最左边的值

### 思路
判断什么时候到最底层和判断什么时候到了下一层一样，queue2的peek()就是最底层最左边的节点

```java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue1 = new LinkedList<>();
        Queue<TreeNode> queue2 = new LinkedList<>();
        if (root != null) {
            queue1.offer(root);
        }
        int bottomLeft = root.val;
        while (!queue1.isEmpty()) {
            TreeNode node = queue1.poll();

            if (node.left != null) {
                queue2.offer(node.left);
            }
            if (node.right != null) {
                queue2.offer(node.right);
            }
            if (queue1.isEmpty()) {
                queue1 = queue2;
                queue2 = new LinkedList<>();
                if (!queue1.isEmpty()) { //如果下一层还有节点，更新最底层最左边节点
                    bottomLeft = queue1.peek().val;
                }
            }
        }
        return bottomLeft;
    }
}
```



## 面试题46：二叉树的右侧视图

### 思路

相当于返回每一层最右侧节点值

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> view = new LinkedList<>();
        if (root == null) {
            return view;
        }
        Queue<TreeNode> queue1 = new LinkedList<>();
        Queue<TreeNode> queue2 = new LinkedList<>();
        queue1.offer(root);
        while (!queue1.isEmpty()) {
            TreeNode node = queue1.poll();
            if (node.left != null) {
                queue2.offer(node.left);
            }
            if (node.right != null) {
                queue2.offer(node.right);
            }
            //到达了当前层最右侧
            if (queue1.isEmpty()) {
                view.add(node.val);
                queue1 = queue2;
                queue2 = new LinkedList<>();
            }
        }
        return view;

    }
}
```


## 二叉树的深度优先搜索

### 中序遍历

#### 递归实现

```java
//中序遍历递归版
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> nodes = new LinkedList<>();
    dfs(root, nodes);
    return nodes;
}

private void dfs(TreeNode root, List<Integer> nodes) {
    if (root != null) {
        dfs(root.left, nodes);
        nodes.add(root.val);
        dfs(root.right, nodes);
    }
}
```

#### 基于栈的迭代实现

```java
public List<Integer> inorderTraversal2(TreeNode root) {
    List<Integer> nodes = new LinkedList<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) { //到达最左子节点
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.pop();
        nodes.add(cur.val);
        cur = cur.right;
    }
    return nodes;
}
```

### 前序遍历

#### 递归实现

```java
//前序遍历递归版
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> nodes = new LinkedList<>();
    dfs2(root, nodes);
    return nodes;
}
private void dfs2(TreeNode root, List<Integer> nodes) {
    if (root != null) {
        nodes.add(root.val);
        dfs2(root.left, nodes);
        dfs2(root.right, nodes);
    }
}
```

#### 基于栈的迭代实现

```java
//前序遍历迭代版
public List<Integer> preorderTraversal2(TreeNode root) {
    List<Integer> result = new LinkedList<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) {
            result.add(cur.val); //先加该节点，再到最左节点
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.pop();
        cur = cur.right;
    }
    return result;
}
```

### 后序遍历

#### 递归版

```java
//后序遍历递归版
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> nodes = new LinkedList<>();
    dfs(root, nodes);
    return nodes;
}
private void dfs3(TreeNode root, List<Integer> nodes) {
    if (root != null) {
        dfs(root.left, nodes);
        dfs(root.right, nodes);
        nodes.add(root.val);
    }
}
```

#### 基于栈的迭代版

```java
//后序遍历迭代版
public List<Integer> postorderTraversal3(TreeNode root) {
    List<Integer> result = new LinkedList<>();
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    TreeNode prev = null;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) { //到达最左节点
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.peek();
        if (cur.right != null && cur.right != prev) { //说明cur右子节点的子树还没遍历完
            cur = cur.right;
        } else { 
            stack.pop();
            result.add(cur.val); //说明右子树都遍历完了，现在遍历当前节点
            prev = cur;
            cur = null;
        }
    }
    return result;
}
```

## 面试题47：二叉树剪枝

### 思路

所谓删除一个节点，就是返回null给它的父节点

```java
class Solution {
    public TreeNode pruneTree(TreeNode root) {
        if (root != null) {
            root.left = pruneTree(root.left); //要把结果返回给root.left,root.right
            root.right = pruneTree(root.right);
            if (root.left == null && root.right == null && root.val == 0) {
                return null;
            } else {
                return root;
            }
        } else {
            return null;
        }
    }
}
```

## 面试题48：序列化和反序列化二叉树

### 思路

- java的基本数据类型，是值传递，传递的是一个实参的拷贝，在方法内对形参的修改不会影响到实参数
- java的引用数据类型，比如对象引用，接口引用，数组引用。是引用传递，传递的是对象的内存地址，方法对引用的操作会影响实际对象。

```java
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null) {
            return "#";
        }
        String leftStr = serialize(root.left);
        String rightStr = serialize(root.right);
        return String.valueOf(root.val) + "," + leftStr + "," + rightStr;
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] nodeStrs = data.split(",");
        int[] i = {0}; //一个指针
        return dfs(nodeStrs, i);
    }
    private TreeNode dfs(String[] strs, int[] i) {
        String str = strs[i[0]];
        i[0]++;//指针向后移

        if (str.equals("#")) {
            return null;
        }

        TreeNode node = new TreeNode(Integer.valueOf(str));
        node.left = dfs(strs, i);
        node.right = dfs(strs, i);
        return node;
    }
}
```
## 面试题49：从根节点到叶节点的路径数字之和

### 思路

```java
class Solution {
    public int sumNumbers(TreeNode root) {
        return dfs(root, 0);
    }
    //path是指到当前节点前面的值
    private int dfs(TreeNode root, int path) {
        if (root == null) {
            return 0;
        }
        path = path * 10 + root.val;//到当前节点的值
        if (root.left == null && root.right == null) { //到达叶子节点之后就不用向下遍历了，需要返回值了
            return path;
        }
        return dfs(root.left, path) + dfs(root.right, path);

    }
}
```



## 面试题50：向下的路径节点值之和

### 思路

leetcode上注意用int型，path会溢出，要用Long类型表示路径和

```java

class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        Map<Long, Integer> map = new HashMap<>();
        map.put(0l, 1);

        return dfs(root, targetSum, map, 0l);
    }
    private int dfs(TreeNode root, int sum, Map<Long, Integer> map, long path) {
        if (root == null) {
            return 0;
        }
        path += root.val;
        int count = map.getOrDefault(path - sum, 0);
        map.put(path, map.getOrDefault(path, 0) + 1);

        count += dfs(root.left, sum, map, path);
        count += dfs(root.right, sum, map, path);
        map.put(path, map.get(path) - 1); //回溯 重要！！！因为相比递归深度优先遍历多了一个map需要记录从根节点到当前节点到路径和，所以遍历完之后需要回到父节点，此时，要把map中当前节点到记录删除掉。
        return count;
    }
}
```

## 面试题51：节点值之和最大的路径

### 思路

```java
class Solution {
    public int maxPathSum(TreeNode root) {
        int[] maxSum = {Integer.MIN_VALUE};
        dfs(root, maxSum);
        return maxSum[0];
    }
    private int dfs(TreeNode root, int[] maxSum) {
        if (root == null) {
            return 0;
        }
        int[] maxSumLeft = {Integer.MIN_VALUE};
        int left = Math.max(0, dfs(root.left, maxSumLeft));//当前节点左子树的最大路径和，不含当前节点

        int[] maxSumRight = {Integer.MIN_VALUE};
        int right = Math.max(0, dfs(root.right, maxSumRight));

        maxSum[0] = Math.max(maxSumLeft[0], maxSumRight[0]);
        maxSum[0] = Math.max(maxSum[0], root.val + left + right); //left是左子树中只经过左子节点的最大值，没有同时经过左子节点的左右子节点

        return root.val + Math.max(left, right);//返回的值是用于上面的和root.val加起来计算的，所以只经过当前节点和一边的路径和
    }
}
```

## 二叉搜索树

### 在二叉搜索树中根据节点值查找对应节点的的代码

```java
//在二叉搜索树中查找值
public TreeNode searchBST(TreeNode root, int val) {
    TreeNode cur = root;
    while (cur != null) {
        if (cur.val == val) {
            break;
        }
        if (cur.val < val) {
            cur = cur.right;
        } else {
            cur = cur.left;
        }
    }
    return cur;
}
```

## 面试题52：展开二叉搜索树

### 思路
按中序遍历，每遍历到一个节点要把前一个节点的指向右子节点的指针指向它。

```java
class Solution {
    public TreeNode increasingBST(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        TreeNode prev = null;
        TreeNode first = null;
        while (cur != null || !stack.isEmpty()) {
            while (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();

            if (prev != null) {
                prev.right = cur;
            } else {
                first = cur;
            }
            prev = cur;
            cur.left = null;

            cur = cur.right;
        }
        return first;
    }
}
```

--- 

## 面试题53：二叉搜索树的下一个节点

### 思路

- 中序遍历：同时用一个found记录是否找到p节点，如果找到了，那么下一个遍历的节点就是要找的节点。这种解法没有利用二叉搜索树的特性

```java
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        boolean found = false;
        while (cur != null || !stack.isEmpty()) {
            while (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            if (found) {
                break;
            } else if (cur == p) {
                found = true;
            }
            cur = cur.right;
        }
        return cur;
    }
}
```

- 在二叉搜索树中找值比p大的最小的节点

```java
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        TreeNode cur = root;
        TreeNode result = null;
        while (cur != null) {
            if (cur.val > p.val) {
                result = cur;
                cur = cur.left;
            } else {
                cur = cur.right;
            }
        }
        return result;
    }
}
```

## 面试题54：所有大于或等于节点的值之和

### 思路

中序遍历，但是先右后左，同时记录已遍历节点的和

```java
class Solution {
    public TreeNode convertBST(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        int sum = 0;
        while (cur != null || !stack.isEmpty()) {
            while (cur != null) {
                stack.push(cur);
                cur = cur.right;
            }
            cur = stack.pop();
            sum += cur.val;
            cur.val = sum;
            cur = cur.left;
        }
        return root;
    }
}
```

---
## 面试题55：二叉搜索树迭代器

### 思路

```java
class BSTIterator {

    TreeNode cur;
    Stack<TreeNode> stack;

    public BSTIterator(TreeNode root) {
        cur = root;
        stack = new Stack<>();
    }
    
    public int next() {
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.pop();
        int val = cur.val;
        cur = cur.right;
        return val;
    }
    
    public boolean hasNext() {
        return cur != null || !stack.isEmpty();
    }
}
```

---

## 面试题56：二叉搜索树中两个节点的值之和

### 思路

```java
class Solution {
    public boolean findTarget(TreeNode root, int k) {
        Set<Integer> set = new HashSet<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()) {
            while (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            if (set.contains(k - cur.val)) {
                return true;
            }
            set.add(cur.val);
            cur = cur.right;
        }
        return false;
    }
}
```
---
## TreeSet和TreeMap的应用

---
## 面试题57：值和下标之差都在给定的范围内

### 思路
用TreeSet，平衡的二叉搜索树。有ceiling，和floor方法
```java
class Solution {
    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        TreeSet<Long> set = new TreeSet<>();
        for (int i = 0; i < nums.length; i++) {
            Long lower = set.floor((long)nums[i]);
            if (lower != null && (long)nums[i] - lower <= t) {
                return true;
            }

            Long upper = set.ceiling((long)nums[i]);
            if (upper != null && upper - (long)nums[i] <= t) {
                return true;
            }
            set.add((long)nums[i]);
            if (i >= k) {
                set.remove((long)nums[i - k]);
            }
        }
        return false;
    }
}
```
---

## 面试题58：日程表

### 思路

找出小于开始时间最晚的，看它的结束时间是不是不开始时间晚；以及找出大于开始时间最早的，看它的开始时间是不是比结束时间早；

![img_1.png](../../../assets/img/img29.png)

```java
class MyCalendar {

    TreeMap<Integer, Integer> events;

    public MyCalendar() {
        events = new TreeMap<>();
    }
    
    public boolean book(int start, int end) {
        Map.Entry<Integer, Integer> event = events.floorEntry(start);
        if (event != null && event.getValue() > start) {
            return false;
        }

        event = events.ceilingEntry(start);
        if (event != null && event.getKey() < end) {
            return false;
        }
        events.put(start, end);
        return true;
    }
}
```


- 主要使用的数据结构就是PriorityQueue，和Queue接口的LinkedList一样，用offer，poll，peek函数
- PriorityQueue是堆，不是队列，虽然实现了Queue接口
---

## 面试题59：数据流的第k大数字

### 思路

```java
class KthLargest {
    private PriorityQueue<Integer> minHeap;
    private int size;

    public KthLargest(int k, int[] nums) {
        size = k;
        minHeap = new PriorityQueue<>();
        for (int num : nums) {
            add(num);
        }
    }
    
    public int add(int val) {
        minHeap.offer(val);
        if (minHeap.size() > size) {
            minHeap.poll();
        }
        return minHeap.peek();
    }
}
```
---
## 面试题60：出现频率最高的k个数字

### 思路

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Queue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(
            (e1, e2) -> e1.getValue() - e2.getValue()
        );
        Map<Integer, Integer> numToCount = new HashMap<>();
        for (int num : nums) {
            numToCount.put(num, numToCount.getOrDefault(num, 0) + 1);
        }

        for (Map.Entry<Integer, Integer> entry : numToCount.entrySet()) {
            if (minHeap.size() < k) {
                minHeap.offer(entry);
            } else {
                minHeap.offer(entry);
                minHeap.poll();
            }
        }
        int[] result = new int[minHeap.size()];
        int i = 0;
        for (Map.Entry<Integer, Integer> entry : minHeap) {
            result[i++] = entry.getKey();
        }
        return result;
    }
}
```
---

## 面试题61：和最小的k个数对

### 思路
重点在于怎么创建最大堆的比较规则
```java
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        Queue<int[]> maxHeap = new PriorityQueue<>(
            (p1, p2) -> (p2[0] + p2[1]) - (p1[0] + p1[1])
        );
        for (int i = 0; i < Math.min(k, nums1.length); i++) {
            for (int j = 0; j < Math.min(k, nums2.length); j++) {
                if (maxHeap.size() < k) {
                    maxHeap.offer(new int[]{nums1[i], nums2[j]});
                } else {
                    maxHeap.offer(new int[]{nums1[i], nums2[j]});
                    maxHeap.poll();
                }
            }
        }

        List<List<Integer>> result = new LinkedList<>();
        while (!maxHeap.isEmpty()) {
            int[] vals = maxHeap.poll();
            result.add(Arrays.asList(vals[0], vals[1]));
        }
        return result;



    }
}
```


### 在递增排序数组中进行二分查找

```java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return -1;
}
```



## 面试题62：实现前缀树

### 思路

```java
class Trie {
    //前缀树的节点结构
    static class TrieNode {
        TrieNode children[];
        boolean isWord;
        public TrieNode() {
            children = new TrieNode[26];
        }
    }
    private TrieNode root;
    /** Initialize your data structure here. */
    public Trie() {
        root = new TrieNode();
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        TrieNode node = root;
        for (char ch : word.toCharArray()) {
            if (node.children[ch - 'a'] == null) {
                node.children[ch - 'a'] = new TrieNode();
            }
            node = node.children[ch - 'a'];
        }
        node.isWord = true;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        TrieNode node = root;
        for (char ch : word.toCharArray()) {
            if (node.children[ch - 'a'] == null) {
                return false;
            }
            node = node.children[ch - 'a'];
        }
        return node.isWord == true;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        TrieNode node = root;
        for (char ch : prefix.toCharArray()) {
            if (node.children[ch - 'a'] == null) {
                return false;
            }
            node = node.children[ch - 'a'];
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```
---
## 面试题63：替换单词

### 思路

```java
class Solution {
    static class TrieNode {
        TrieNode[] children;
        boolean isWord;
        public TrieNode() {
            children = new TrieNode[26];
        }
    }
    public String replaceWords(List<String> dictionary, String sentence) {
        TrieNode root = buildTrie(dictionary);
        String[] words = sentence.split(" ");
        for (int i = 0; i < words.length; i++) {
            String replaceWord = findPrefix(root, words[i]);
            //if (replaceWord != null) {
            if (!replaceWord.isEmpty()) { //!!!! 没有词根的时候是返回“”，要用isEmpty()判断，而不是判断是不是null
                words[i] = replaceWord;
            }
        }
        return String.join(" ", words);
    }

    private TrieNode buildTrie(List<String> dictionary) {
        TrieNode root = new TrieNode();
        for (String word : dictionary) {
            TrieNode node = root;
            for (char ch : word.toCharArray()) {
                if (node.children[ch - 'a'] == null) {
                    node.children[ch - 'a'] = new TrieNode();
                }
                node = node.children[ch - 'a'];
            }
            node.isWord = true;
        }
        return root;
    }

    private String findPrefix(TrieNode root, String word) {
        TrieNode node = root;
        StringBuilder sb = new StringBuilder();
        for (char ch : word.toCharArray()) {
            if (node.children[ch - 'a'] == null || node.isWord) {
                break;
            }
            sb.append(ch);
            node = node.children[ch - 'a'];
        }
        return node.isWord ? sb.toString() : "";
    }
}
```
---
## 面试题64：神奇的字典

### 思路

![img_1.png](../../../assets/img/img30.png)

```java
class MagicDictionary {

    static class TrieNode {
        TrieNode[] children;
        boolean isWord;
        public TrieNode() {
            children = new TrieNode[26];
        }
    }

    TrieNode root;

    /** Initialize your data structure here. */
    public MagicDictionary() {
        root = new TrieNode();
    }
    
    public void buildDict(String[] dictionary) {
        for (String word : dictionary) {
            TrieNode node = root;
            for (char ch : word.toCharArray()) {
                if (node.children[ch - 'a'] == null) {
                    node.children[ch - 'a'] = new TrieNode();
                }
                node = node.children[ch - 'a'];
            }
            node.isWord = true;
        }
    }
    
    public boolean search(String searchWord) {
        return dfs(root, searchWord, 0, 0);
    }
    //第三个参数表示正在遍历的字符下标，第四个参数表示修改字符串的字符次数
    private boolean dfs(TrieNode root, String word, int index, int edit) {
        if (root == null) {
            return false;
        }
        if (root.isWord && index == word.length() && edit == 1) {
            return true;
        }
        if (index < word.length() && edit <= 1) {
            boolean found = false;
            for (int j = 0; j < 26 && !found; j++) {
                int nextEditNum = (j == word.charAt(index) - 'a') ? edit : edit + 1;
                found = dfs(root.children[j], word, index + 1, nextEditNum);
            }
            return found;
        }
        return false;
    }
}

/**
 * Your MagicDictionary object will be instantiated and called as such:
 * MagicDictionary obj = new MagicDictionary();
 * obj.buildDict(dictionary);
 * boolean param_2 = obj.search(searchWord);
 */
```

---

## 面试题65：最短的单词编码

### 思路

```java
class Solution {
    static class TrieNode {
        public TrieNode[] children;
        public TrieNode() {
            children = new TrieNode[26];
        }
    }
    public int minimumLengthEncoding(String[] words) {
        TrieNode root = buildTrie(words);
        int[] total = {0};
        dfs(root, 1, total);
        return total[0];
    }
    private TrieNode buildTrie(String[] words) {
        TrieNode root = new TrieNode();
        for (String word : words) {
            TrieNode node = root;
            for (int i = word.length() - 1; i >= 0; i--) {
                if (node.children[word.charAt(i) - 'a'] == null) {
                    node.children[word.charAt(i) - 'a'] = new TrieNode();
                }
                node = node.children[word.charAt(i) - 'a'];
            }
        }
        return root;
    }
    //要记住遍历的方法
    private void dfs(TrieNode root, int length, int[] total) {
        boolean isLeaf = true;
        for (TrieNode child : root.children) {
            if (child != null) {
                isLeaf = false;
                dfs(child, length + 1, total);
            }
        }
        if (isLeaf) {
            total[0] += length;
        }
    }
}
```
---
## 面试题66：单词之和

### 思路

```java
class MapSum {

    static class TrieNode {
        public TrieNode[] children;
        public int value;
        public TrieNode() {
            children = new TrieNode[26];
        }
    }
    private TrieNode root;
    /** Initialize your data structure here. */
    public MapSum() {
        root = new TrieNode();
    }
    
    public void insert(String key, int val) {
        TrieNode node = root;
        for (int i = 0; i < key.length(); i++) {
            char ch = key.charAt(i);
            if (node.children[ch - 'a'] == null) {
                node.children[ch - 'a'] = new TrieNode();
            }
            node = node.children[ch - 'a'];
        }
        node.value = val;
    }
    
    public int sum(String prefix) {
        TrieNode node = root;
        for (int i = 0; i < prefix.length(); i++) {
            char ch = prefix.charAt(i);
            if (node.children[ch - 'a'] == null) {
                return 0;
            }
            node = node.children[ch - 'a'];
        }
        return getSum(node);
    }
    private int getSum(TrieNode node) {
        if (node == null) {
            return 0;
        }
        int result = node.value;
        for (TrieNode n : node.children) {
            result += getSum(n);
        }
        return result;
    }
}

/**
 * Your MapSum object will be instantiated and called as such:
 * MapSum obj = new MapSum();
 * obj.insert(key,val);
 * int param_2 = obj.sum(prefix);
 */
```
---

## 面试题67：最大的异或

### 思路

```java
class Solution {
    static class TrieNode {
        public TrieNode[] children;
        public TrieNode() {
            children = new TrieNode[2];
        }
    }
    public int findMaximumXOR(int[] nums) {
        TrieNode root = buildTrie(nums);
        int max = 0;
        for (int num : nums) {
            int xor = 0;

            TrieNode node = root;
            for (int i = 31; i >= 0; i--) {
                int bit = (num >> i) & 1;
                if (node.children[1 - bit] != null) {
                    xor = (xor << 1) + 1;
                    node = node.children[1 - bit];
                } else {
                    xor = xor << 1;
                    node = node.children[bit];
                }
            }

            max = Math.max(max, xor);
        }
        return max;
    }
    private TrieNode buildTrie(int[] nums) {
        TrieNode root = new TrieNode();
        for (int num : nums) {
            TrieNode node = root;
            for (int i = 31; i >= 0; i--) {
                int bit = (num >> i) & 1;
                if (node.children[bit] == null) {
                    node.children[bit] = new TrieNode();
                }
                node = node.children[bit];
            }
        }
        return root;
    }
}
```

---

## 面试题68：查找插入位置

### 思路

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] >= target) {
                if ( mid == 0 || nums[mid - 1] < target) {
                    return mid;
                }
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return nums.length;

    }
}
```
---
## 面试题69：山峰数组的顶部

### 思路

```java
class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        int left = 1;
        int right = arr.length - 2;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (arr[mid] > arr[mid - 1] && arr[mid] > arr[mid + 1]) {
                return mid;
            }
            if (arr[mid] > arr[mid - 1]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
}
```
---

## 面试题70：排序数组中只出现一次的数字

### 思路

![img_1.png](../../../assets/img/img31.png)

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int left = 0;
        int right = nums.length / 2;
        while (left <= right) {
            int mid = (left + right) / 2;
            int i = mid * 2;
            if (i < nums.length - 1 && nums[i] != nums[i + 1]) {
                if (mid == 0 || nums[i - 1] == nums[i - 2]) {
                    return nums[i];
                }
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return nums[nums.length - 1];
    }
}
```
---
## 面试题71：按权重生成随机数

### 思路

```java
class Solution {
    private int[] sums;
    private int total;

    public Solution(int[] w) {
        sums = new int[w.length];
        for (int i = 0; i < w.length; i++) {
            total += w[i];
            sums[i] = total;
        }
    }
    
    public int pickIndex() {
        Random random = new Random();
        int p = random.nextInt(total);

        int left = 0;
        int right = sums.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (sums[mid] > p) {
                if (mid == 0 || sums[mid - 1] <= p) {
                    return mid;
                }
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(w);
 * int param_1 = obj.pickIndex();
 */
```

---

## 在数值范围内二分查找

---

## 面试题72：求平方根

### 思路

```java
class Solution {
    public int mySqrt(int x) {
        int left = 1;
        int right = x;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (mid <= x / mid) {
                if ((mid + 1) > x / (mid + 1)) {
                    return mid;
                }
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return 0;

    }
}
```
---
## 面试题73：狒狒吃香蕉

### 思路

当吃香蕉速度为k的时候，计算以k的速度吃完所有香蕉需要的时间。
> 假设一堆有pile根，那么以k的速度吃完该堆所需要的时间是：pile / k 向上取整，简化为(pile + k - 1)/k

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int max = 0;
        for (int pile : piles) {
            max = Math.max(max, pile);
        }

        int left = 1;
        int right = max;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (getHour(piles, mid) <= h) {
                if (mid == 1 || getHour(piles, mid - 1) > h) {
                    return mid;
                }
                right = mid - 1;//可以再慢点吃
            } else {
                left = mid + 1;
            }
        }
        return -1;
    }

    private int getHour(int[] piles, int h) {
        int hour = 0;
        for (int pile : piles) {
            hour += (pile + h - 1) / h;
        }
        return hour;
    }
}
```

