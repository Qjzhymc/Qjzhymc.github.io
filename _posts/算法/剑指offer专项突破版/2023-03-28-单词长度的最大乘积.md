---
title: 面试题5：单词长度的最大乘积
author: Yu Mengchi
categories:
  - 算法 
  - 剑指offer-专项突破版
tags:
  - Interview
  - 算法
  - 二进制
  - 整数
---


---

## 题目
> 输入一个字符串数组words，请计算不包含相同字符的两个字符串words[i]和words[j]的长度乘积的最大值。
> 如果所有字符串都包含至少一个相同字符，那么返回0。假设字符串中只包含英文小写字母。
> 例如，输入的字符串数组words位["abcw","foo","bar","fxyz","abcdef"],数组中
> 的字符串"bar"与"foo"没有相同的字符，它们长度的乘积为9。"abcw"与"fxyz"也没有相同的字符，它们长度的乘积为16，
> 这是该数组不包含相同字符的一对字符串的长度乘积的最大值。

---

## 思路

### 解法1

首先直观想法是对于每个字符串，判断它与另一个字符串是否有相同字符，如果没有，则更新长度乘积最大值。
所以问题就是如何判断两个字符串有没有相同字符，解法1的思路是用一个26长度的boolean型数组表示26个字母在
字符串1中出现情况，然后用字符串1的数组和字符串2的数组进行每一位的比较，如果每一位都不同时为1，说明两个字符串
没有重复的字符。

![img_1.png](../../../assets/img/img11.png)


代码如下：

```Java
    public static int maxProduct(String[] words) {
        boolean[][] flags = new boolean[words.length][26];
        for (int i = 0; i < words.length; i++) {
            for (int j = 0; j < words[i].length(); j++) {
                char ch = words[i].charAt(j);
                flags[i][ch-'a'] = true;
            }
        }

        int result = 0;
        for (int i = 0; i < words.length; i++) {
            for (int j = i; j < words.length; j++) {
                //这里把k的定义放到for循环外面来，方便for循环之后后面的if判断，要学会这种写法
                int k = 0;
                for (; k < 26; k++) {
                    if (flags[i][k] && flags[j][k]) {
                        break;
                    }
                    
                }
                if (k == 25) {
                  int prod = words[i].length() * words[j].length();
                  result = Math.max(result, prod);
                }
            }
        }
        return result;
    }
```

---

### 解法2


