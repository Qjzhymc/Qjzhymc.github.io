---
title: 排序
author: Yu Mengchi
categories:
  - 算法
  - 剑指offer-专项突破版
  - 排序
tags:
  - Interview
  - 算法
  - 排序
---
  
## 插入排序

## 冒泡排序

## 堆排序

## 计数排序

## 归并排序

## 快速排序

---

## 面试题74：合并区间

### 思路

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (i1, i2) ->  (i1[0] - i2[0]));
        int i = 0;
        List<int[]> merged = new LinkedList<>();
        while (i < intervals.length) {
            int[] temp = new int[]{intervals[i][0], intervals[i][1]};
            int j = i + 1;
            while (j < intervals.length && intervals[j][0] <= temp[1]) {
                temp[1] = Math.max(intervals[j][1], temp[1]);
                j++;
            }
            merged.add(temp);
            i = j;
        }
        int[][] result = new int[merged.size()][];
        return merged.toArray(result);
    }
}
```
---
## 计数排序

---
## 面试题75：数组相对排序

### 思路
先统计每个数字出现次数，然后按照nums2数组的顺序一个个放入新数组中
```java
class Solution {
    public int[] relativeSortArray(int[] arr1, int[] arr2) {
        int[] counts = new int[1001];
        for (int num : arr1) {
            counts[num]++;
        }

        int i = 0;
        for (int num : arr2) {
            while (counts[num] > 0) {
                arr1[i] = num;
                counts[num]--;
                i++;
            }
        }

        for (int num = 0; num < 1001; num++) {
            while (counts[num] > 0) {
                arr1[i] = num;
                counts[num]--;
                i++;
            }
         }
         return arr1;
    }
}
```
---
## 快速排序

---

## 面试题76：数组中第k大的数字

### 思路

第k大的数在一个排序的数组中，它的下表应该是length - k，所以用快速排序，一个partition得到index，判断
index是不是length - k，如果得到的index大于length - k，则从左边子数组中继续分区。

![img_1.png](../../../assets/img/img32.png)

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int target = nums.length - k;
        int start = 0;
        int end = nums.length - 1;
        int index = partition(nums, start, end);
        while (index != target) {
            if (index > target) {
                end = index - 1;
            } else {
                start = index + 1;
            }
            index = partition(nums, start, end);
        }
        return nums[index];
    }

    private int partition(int[] nums, int start, int end) {
        int random = new Random().nextInt(end - start + 1) + start;
        swap(nums, random, end);
        int p1 = start - 1;
        for (int p2 = start; p2 < end; p2++) {
            if (nums[p2] < nums[end]) {
                p1++;
                swap(nums, p1, p2);
            }
        }
        p1++;
        swap(nums, p1, end);
        return p1;
    }
    private void swap(int[] nums, int p, int q) {
        int temp = nums[p];
        nums[p] = nums[q];
        nums[q] = temp;
    }
}
```
---
## 归并排序

---

## 面试题77：链表排序

### 思路
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode head1 = head;
        ListNode head2 = split(head);
        head1 = sortList(head1);
        head2 = sortList(head2);
        return merge(head1, head2);
    }
    private ListNode split(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode fast = dummy;
        ListNode slow = dummy;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next;
            if (fast.next != null) {
                fast = fast.next;
            }
        }
        ListNode head2 = slow.next;
        slow.next = null;
        return head2;
    }
    private ListNode merge(ListNode head1, ListNode head2) {
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        while (head1 != null && head2 != null) {
            if (head1.val < head2.val) {
                cur.next = head1;
                head1 = head1.next;
            } else {
                cur.next = head2;
                head2 = head2.next;
            }
            cur = cur.next;
        }
        cur.next = head1 == null ? head2 : head1;
        return dummy.next;
    }
}
```
---
## 面试题78：合并排序链表

### 思路

最小堆 或 归并排序

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((l1, l2) -> (l1.val - l2.val));
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        for (ListNode node : lists) {
            if (node != null) {
                minHeap.offer(node);
            }
        }

        while (!minHeap.isEmpty()) {
            ListNode minNode = minHeap.poll();
            cur.next = minNode;
            cur = minNode;
            if (minNode.next != null) {
                minHeap.offer(minNode.next);
            }
        }
        return dummy.next;
    }
}
```
