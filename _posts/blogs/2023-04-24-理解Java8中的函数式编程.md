---
title: 理解Java8中的函数式编程
author: Yu Mengchi
categories:
  - Java
tags:
  - Java
  - 函数式编程
---
  
Java8中引入了函数式编程的支持，也介绍了一些新概念，尤其是Lambda表达式、方法引用、一些函数式接口，比如Consumer、
Supplier、Predicate和Functions

## Consumer


## Supplier

下面是Supplier接口的定义，里面就只有一个get方法，用于返回指定类型T的数据。

```java
package java.util.function;

/**
 * Represents a supplier of results.
 *
 * <p>There is no requirement that a new or distinct result be returned each
 * time the supplier is invoked.
 *
 * <p>This is a <a href="package-summary.html">functional interface</a>
 * whose functional method is {@link #get()}.
 *
 * @param <T> the type of results supplied by this supplier
 *
 * @since 1.8
 */
@FunctionalInterface
public interface Supplier<T> {

    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}
```

使用的时候先定义Supplier对象，传入其他方法method。之后每次使用该Supplier对象的get()方法的时候，就会返回method()方法生成的结果。
其实这种方式和直接定义一个method()返回的对象有什么区别呢？
比如下面这两种方式得到的数据都是相同的，那为什么要加一种Supplier接口通过get方法的方式获取数据呢？
```java
Supplier<LocalDate> s1 = LocalDate::now;
LocalDate s2 = LocalDate.now();

System.out.println(s1.get()); //2016-10-25
System.out.println(s2); //2016-10-25
```

- 第一个原因是，和使用变量一样的道理，当需要使用一个结果的时候，我们其实可以每次都在需要的时候重新计算就可以了。
所以如果需要使用一个方法，但是这个方法有很长的语法，就可以用一个Supplier对象表示，不需要每次都调用很长的
方法。

```java
Supplier<MyAmazingClass> shorter = MyAmazingClass::MyEvenBetterMethod;

int myVar = shorter.get();
// ...
int myOtherVar = shorter.get();
```

- 第二个原因是，Supplier可以用来延迟执行，比如调用当前时间，每次用Supplier对象的get，得到的时候就会是当前时间。
如果一开始就用一个变量保存的话，那就没法得到实时的时间了。

比如下面的例子。
```java
import java.time.LocalDateTime;
import java.util.function.Supplier;

public class Main {
    public static void main(String[] args) throws InterruptedException {
        // Create a reference to the current date-time object when the following line is
        // executed
        LocalDateTime ldt = LocalDateTime.now();
        System.out.println(ldt);// Line-1

        // Create a reference to a functionality that will get the current date-time
        // whenever this functionality will be used
        Supplier<LocalDateTime> dateSupplier = LocalDateTime::now;

        // Sleep for 5 seconds
        Thread.sleep(5000);

        System.out.println(ldt);// Will display the same value as Line-1
        System.out.println(dateSupplier.get());// Will display the current date-time when this line will be executed

        // Sleep again for 5 seconds
        Thread.sleep(5000);

        System.out.println(ldt);// Will display the same value as Line-1
        System.out.println(dateSupplier.get());// Will display the current date-time when this line will be executed
    }
}
```

## Predicate


## Function


